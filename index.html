<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>from a get set world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hexo theme - Icarus">
<meta property="og:type" content="website">
<meta property="og:title" content="from a get set world">
<meta property="og:url" content="www.getsetter.cn/index.html">
<meta property="og:site_name" content="from a get set world">
<meta property="og:description" content="Hexo theme - Icarus">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="from a get set world">
<meta name="twitter:description" content="Hexo theme - Icarus">
  
  
    <link rel="icon" href="favicon.png">
  
  <link href='//fonts.useso.com/css?family=Open+Sans:400italic,400,600' rel='stylesheet' type='text/css'>
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/hexo-theme-icarus/css/style.css" type="text/css">
  <link rel="stylesheet" href="/hexo-theme-icarus/font-awesome/css/font-awesome.min.css" type="text/css">
  

  
</head>
<body>
  <div id="container">
    <header id="header">
  <div id="header-main" class="header-inner">
    <div class="outer">
      <a href="/" id="logo"><i class="logo" style="background-image: url(/hexo-theme-icarus/css/images/logo.png)"></i><span class="site-title">from a get set world</span></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/hexo-theme-icarus/.">Home</a>
        
          <a class="main-nav-link" href="/hexo-theme-icarus/archives">Archives</a>
        
          <a class="main-nav-link" href="/hexo-theme-icarus/about">About</a>
        
      </nav>
      
        <nav id="sub-nav">
          <div class="profile" id="profile-nav">
            <a id="profile-anchor" href="javascript:;"><img class="avatar" src="/hexo-theme-icarus/img/my.jpg"><i class="fa fa-caret-down"></i></a>
          </div>
        </nav>
      
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="www.getsetter.cn"></form>
      </div>
    </div>
  </div>
  <div id="main-nav-mobile" class="header-sub header-inner">
    <table class="menu outer">
      <tr>
        
          <td><a class="main-nav-link" href="/hexo-theme-icarus/.">Home</a></td>
        
          <td><a class="main-nav-link" href="/hexo-theme-icarus/archives">Archives</a></td>
        
          <td><a class="main-nav-link" href="/hexo-theme-icarus/about">About</a></td>
        
        <td>
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="www.getsetter.cn"></form>
        </td>
      </tr>
    </table>
  </div>
</header>

    <div class="outer">
      
        <aside id="profile">
  <div class="inner profile-inner">
    <div class="base-info profile-block">
      <img id="avatar" src="/hexo-theme-icarus/img/my.jpg">
      <h2 id="name">家栋</h2>
      <h3 id="title">java Developer</h3>
      <span id="location"><i class="fa fa-map-marker"></i>hangzhou, China</span>
      <a id="follow" href="https://github.com/owenludong/">FOLLOW</a>
    </div>
    <div class="article-info profile-block">
      <div class="article-info-block">
        7
        <span>posts</span>
      </div>
      <div class="article-info-block">
        0
        <span>tag</span>
      </div>
    </div>
    
    <div class="contact-info profile-block">
      <table class="contact-list">
        <tr>
          
          <td><a href="http://github.com/owenludong" target="_blank" title="github"><i class="fa fa-github"></i></a></td>
          
          <td><a href="http://weibo.com/p/1005051884112540/home" target="_blank" title="weibo"><i class="fa fa-weibo"></i></a></td>
          
        </tr>
      </table>
    </div>
    
    
  </div>
</aside>

      
      <section id="main">
      <article id="post-share_ali_tec_metting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexo-theme-icarus/2014/08/01/share_ali_tec_metting/">参加阿里巴巴2015阿里系统技术峰会的感受</a>
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/hexo-theme-icarus/2014/08/01/share_ali_tec_metting/">
      <time datetime="2014-08-01T15:25:17.000Z" itemprop="datePublished">2014-08-01</time>
    </a>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <p>阿里系统技术峰会是由阿里巴巴举办的一次围绕运维层面的一次技术交流。上午的topic因为没啥吸引力就选择了下午场。</p>
<p>到会场后刚好是几位大佬的一次圆桌会议，不过其中我也就认识技术保障部门的老大——振飞、天猫技术部人负责人——范禹和蚂蚁金服CTO——鲁肃。印象比较深刻的应该还是鲁肃说的自己对蚂蚁金服2015年的几件比较激动人心的事情：</p>
<ul>
<li>用阿里云的Iaas作为基础实施，把蚂蚁金融的paas做起来，实现一个云化的金融生态体系。</li>
<li>用蚂蚁金融的技术打造一个银行系统。</li>
<li>14年的双11 支付宝自主研发的oceabase数据库在其中承担了大约10%左右的交易数据量，在15年希望在支付和交易领域能承担更多的存储压力。</li>
<li>让银行的系统来用蚂蚁金服的技术，为他们减少之前支付宝技术道路上摸索的时间。</li>
</ul>
<p>之后是一个来自fb的工程师，腿具长，他带来的是一个概念比较新颖的主题:<a href="http://www.opencompute.org/" target="_blank" rel="external">OCP</a>，全称open compute project。是一个关于数据中心和服务器的硬件开源项目。主要就是对硬件做hack，能够让服务器的能源消耗和输入最大程度地成正比，这个用专有名词来说叫做PUE。其实简单来说就是尽量让机房里做到环保，最少地节省能耗。 在中国有一个项目叫做“天蝎项目”，就是做类似的事情。 </p>
<p>之后的一个分享题目是阿里新生代数据中心，这个topic比较虚，更多是一些探索性的内容，而4月份阿里将会投入使用的千岛湖数据中心，具说PUE可以达到1.4。目前在国内的能耗比算是领先了</p>
<p>何登成在微博还是比较活跃的，他带来的是阿里巴巴从IOE到OceanBase的分享。 去IOE的几个原因：</p>
<ul>
<li>IOE机器太贵</li>
<li>单点</li>
<li>IOE就像黑匣子一样，无法知道几个组件的实现原理，排查问题困难。</li>
</ul>
<p>阿里首先用了分布式mysql来解决去IOE的问题，但是mysql存储容量有限、天然对分布式的不友好，让DBA很难去运维。oceanbase将会在未来部署到更多应用中去。目前阿里云团队的rds是基于mysql存储引擎做的一个云数据库，目前DBA团队也在做一个基于ob的云数据库。</p>
<p>之后是一个新产品alisocket，在linux用户态对tcp协议做了分片，不同线程的互不干扰，并且不同的线程可以监听同一个socket端口</p>
<p>异地多活： 如果要做到异地双活，网络延迟是最大的挑战。如果腾讯QQ做单元化，只有用户自己的数据，所以只有一个维度。而淘宝有买家、卖家、商品3个维度。考虑到买家是淘宝的流量所在，因此对买家做了数据分片，而卖家和商品的数据会部署在数据中心，所以数据中心会有全量的买家、卖家、商品的数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.getsetter.cn/2014/08/01/share_ali_tec_metting/" data-id="cid7fvg420006yfxez1987qpk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



    
      <article id="post-servlet_init" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexo-theme-icarus/2014/08/01/servlet_init/">tomcat初始化servlet代码剖析</a>
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/hexo-theme-icarus/2014/08/01/servlet_init/">
      <time datetime="2014-08-01T15:25:17.000Z" itemprop="datePublished">2014-08-01</time>
    </a>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <p>先抛几个老生常谈的面试问题</p>
<ul>
<li>servlet是在容器启动的时候初始化还是第一次调用的时候初始化？</li>
<li>web.xml中的loadOnstartup用什么用，是指启动延迟时间？</li>
<li>servlet初始化怎么控制并发的？</li>
</ul>
<p>本来主要来读下tomcat源码，知道下tomcat是怎么来处理上面的问题的</p>
<h2 id="servlet初始化时机">servlet初始化时机</h2><p>tomcat是以组件的方式架构整个容器，并且每个组件都会有生命周期，贯穿着tomcat的生老病死。如果对tomcat组件不清楚可以参考我之前写过的一篇<a href="http://www.getsetter.cn/2014/06/25/tomcat-component/">tomcat组件</a></p>
<p>tomcat启动的时候，会去调每个组件的start方法，这里我们关注一下Context组件的启动方法。每一个web应用在tomcat内部都是以Context形式存在的，当我们在CATALINA_BASE/webapps下创建一个web应用时，默认都会创建一个名字为目录名的Context实例。</p>
<p>Context在tomcat容器内部的的实现类是StandardContext，StandardContext启动函数里面有一个loadOnStartup()方法，看一下这个方法</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadOnStartup</span><span class="params">(Container children[])</span> </span>{

    <span class="comment">// Collect "load on startup" servlets that need to be initialized</span>
    TreeMap&lt;Integer, ArrayList&lt;Wrapper&gt;&gt; <span class="built_in">map</span> =
        <span class="keyword">new</span> TreeMap&lt;Integer, ArrayList&lt;Wrapper&gt;&gt;();
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.length; i++) {
        Wrapper wrapper = (Wrapper) children[i];
        <span class="comment">//@1</span>
        <span class="keyword">int</span> loadOnStartup = wrapper.getLoadOnStartup();
        <span class="keyword">if</span> (loadOnStartup &lt; <span class="number">0</span>)
            <span class="keyword">continue</span>;
        Integer key = Integer.valueOf(loadOnStartup);
        ArrayList&lt;Wrapper&gt; <span class="built_in">list</span> = <span class="built_in">map</span>.get(key);
        <span class="keyword">if</span> (<span class="built_in">list</span> == null) {
            <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Wrapper&gt;();
            <span class="built_in">map</span>.put(key, <span class="built_in">list</span>);
        }
        <span class="built_in">list</span>.add(wrapper);
    }

    <span class="comment">// Load the collected "load on startup" servlets</span>
    <span class="keyword">for</span> (ArrayList&lt;Wrapper&gt; <span class="built_in">list</span> : <span class="built_in">map</span>.values()) {
        <span class="keyword">for</span> (Wrapper wrapper : <span class="built_in">list</span>) {
            <span class="keyword">try</span> {
                wrapper.load();
            } <span class="keyword">catch</span> (ServletException e) {
                getLogger().error(sm.getString(<span class="string">"standardWrapper.loadException"</span>,
                                  getName()), StandardWrapper.getRootCause(e));
                <span class="comment">// <span class="doctag">NOTE:</span> load errors (including a servlet that throws</span>
                <span class="comment">// UnavailableException from tht init() method) are NOT</span>
                <span class="comment">// fatal to application startup</span>
            }
        }
    }

}
</code></pre><ul>
<li>方法参数可以理解为多个servlet配置</li>
<li>标注@1处拿到了每个servlet的load-on-starup配置的值，如果值大于0，则会把这个值当key，ArrayList<wrapper>为value放到一个TreeMap,注意TreeMap是一个可以排序的集合，这里key是Integer，那每一次put，就会把key值越小的排在前面。 之后会遍历这个map，调用wrapper的load方法，load()方法会去初始化servlet。</wrapper></li>
</ul>
<p>上面的代码其实回答了最开始的2个疑问，load-on-startup的作用和servlet的初始化时机。容器会根据load-on-startup的配置来启动servlet的优先级，值如果小于0，则不会在容器启动的时候初始化，值越小，就优先加载。</p>
<h2 id="servlet初始化过程">servlet初始化过程</h2><h3 id="SingleThreadModel">SingleThreadModel</h3><p>在分析servlet初始化过程前，先聊聊SingleThreadModel接口，可能很多21世纪的工程师都不知道这个接口，在servlet2.4之前的规范，为了防止并发访问servlet带来的问题，servlet规范规定所有实现SingleThreadModel接口的servlet，会为每一次request实例化一个servlet。在tomcat实现里，会有一个servlet实例计数器，不能超过一个阀值，实现后面会分析。但其实这对大流量的应用无疑是一个灾难,所以这个接口现在已经被作废。</p>
<h3 id="分析servlet的实例化过程">分析servlet的实例化过程</h3><p>前面提到wrapper.load()会去是实例化servlet,这个方法其实就是去调用了loadservlet()方法，我们分析下这个方法</p>
<pre><code><span class="keyword">if</span> <span class="params">(!singleThreadModel &amp;&amp; <span class="params">(instance != null)</span>)</span>
    return instance;

PrintStream out = System.out;
<span class="keyword">if</span> <span class="params">(swallowOutput)</span> {
    SystemLogHandler.startCapture<span class="params">()</span>;
}

Servlet servlet;
try {
    long t1=System.currentTimeMillis<span class="params">()</span>;
    <span class="comment">// Complain if no servlet class has been specified</span>
    <span class="keyword">if</span> <span class="params">(servletClass == null)</span> {
        unavailable<span class="params">(null)</span>;
        throw new ServletException
            <span class="params">(sm.getString<span class="params">(<span class="string">"standardWrapper.notClass"</span>, getName<span class="params">()</span>)</span>)</span>;
    }

    InstanceManager instanceManager = <span class="params">(<span class="params">(StandardContext)</span>getParent<span class="params">()</span>)</span>.getInstanceManager<span class="params">()</span>;
    try {
        servlet = <span class="params">(Servlet)</span> instanceManager.newInstance<span class="params">(servletClass)</span>;
    } catch <span class="params">(ClassCastException e)</span> {
        unavailable<span class="params">(null)</span>;
        <span class="comment">// Restore the context ClassLoader</span>
        throw new ServletException
            <span class="params">(sm.getString<span class="params">(<span class="string">"standardWrapper.notServlet"</span>, servletClass)</span>, e)</span>;
    } catch <span class="params">(Throwable e)</span> {
        e = ExceptionUtils.unwrapInvocationTargetException<span class="params">(e)</span>;
        ExceptionUtils.handleThrowable<span class="params">(e)</span>;
        unavailable<span class="params">(null)</span>;

        <span class="comment">// Added extra log statement for Bugzilla 36630:</span>
        <span class="comment">// http://issues.apache.org/bugzilla/show_bug.cgi?id=36630</span>
        <span class="keyword">if</span><span class="params">(log.isDebugEnabled<span class="params">()</span>)</span> {
            <span class="built_in">log</span>.debug<span class="params">(sm.getString<span class="params">(<span class="string">"standardWrapper.instantiate"</span>, servletClass)</span>, e)</span>;
        }

        <span class="comment">// Restore the context ClassLoader</span>
        throw new ServletException
            <span class="params">(sm.getString<span class="params">(<span class="string">"standardWrapper.instantiate"</span>, servletClass)</span>, e)</span>;
    }

    <span class="keyword">if</span> <span class="params">(multipartConfigElement == null)</span> {
        MultipartConfig annotation =
                servlet.getClass<span class="params">()</span>.getAnnotation<span class="params">(MultipartConfig.class)</span>;
        <span class="keyword">if</span> <span class="params">(annotation != null)</span> {
            multipartConfigElement =
                    new MultipartConfigElement<span class="params">(annotation)</span>;
        }
    }

    processServletSecurityAnnotation<span class="params">(servlet.getClass<span class="params">()</span>)</span>;

    <span class="comment">// Special handling for ContainerServlet instances</span>
    <span class="keyword">if</span> <span class="params">(<span class="params">(servlet instanceof ContainerServlet)</span> &amp;&amp;
            <span class="params">(isContainerProvidedServlet<span class="params">(servletClass)</span> ||
                    <span class="params">(<span class="params">(Context)</span> getParent<span class="params">()</span>)</span>.getPrivileged<span class="params">()</span> )</span>)</span> {
        <span class="params">(<span class="params">(ContainerServlet)</span> servlet)</span>.setWrapper<span class="params">(this)</span>;
    }

    classLoadTime=<span class="params">(int)</span> <span class="params">(System.currentTimeMillis<span class="params">()</span> -t1)</span>;

    <span class="keyword">if</span> <span class="params">(servlet instanceof SingleThreadModel)</span> {
        <span class="keyword">if</span> <span class="params">(instancePool == null)</span> {
            instancePool = new Stack&lt;Servlet&gt;<span class="params">()</span>;
        }
        singleThreadModel = <span class="literal">true</span>;
    }

    initServlet<span class="params">(servlet)</span>;

    fireContainerEvent<span class="params">(<span class="string">"load"</span>, this)</span>;

    loadTime=System.currentTimeMillis<span class="params">()</span> -t1;
} finally {
    <span class="keyword">if</span> <span class="params">(swallowOutput)</span> {
        String <span class="built_in">log</span> = SystemLogHandler.stopCapture<span class="params">()</span>;
        <span class="keyword">if</span> <span class="params">(log != null &amp;&amp; log.length<span class="params">()</span> &gt; <span class="number">0</span>)</span> {
            <span class="keyword">if</span> <span class="params">(getServletContext<span class="params">()</span> != null)</span> {
                getServletContext<span class="params">()</span>.<span class="built_in">log</span><span class="params">(log)</span>;
            } <span class="keyword">else</span> {
                out.println<span class="params">(log)</span>;
            }
        }
    }
}
return servlet;
</code></pre><ul>
<li>代码不难，围绕本章话题主要实现了几点：反射实例化了一个servlet对象,判断servlet是否实现SingleThreadModel接口，调用servlet的init方法。</li>
</ul>
<p>wrapper.load()只是在容器启动的时候去初始化，是个单线程的操作，所以并不会有并发的问题。我们来关注下StandardWrapper.allocate()方法，这个方法会在每次请求servlet的时候初始化servlet，即servlet不是容器启动的时候初始化，这里方法比较长，分2部分分析，第一部分：</p>
<pre><code><span class="keyword">if</span> <span class="params">(!singleThreadModel)</span> {

       <span class="comment">// @1</span>
       <span class="keyword">if</span> <span class="params">(instance == null)</span> {
           synchronized <span class="params">(this)</span> {
               <span class="keyword">if</span> <span class="params">(instance == null)</span> {
                   try {
                       <span class="keyword">if</span> <span class="params">(log.isDebugEnabled<span class="params">()</span>)</span>
                           <span class="built_in">log</span>.debug<span class="params">(<span class="string">"Allocating non-STM instance"</span>)</span>;

                       instance = loadServlet<span class="params">()</span>;
                       <span class="keyword">if</span> <span class="params">(!singleThreadModel)</span> {
                           <span class="comment">// For non-STM, increment here to prevent a race</span>
                           <span class="comment">// condition with unload. Bug 43683, test case</span>
                           <span class="comment">// #3</span>
                           newInstance = <span class="literal">true</span>;
                           countAllocated.incrementAndGet<span class="params">()</span>;
                       }
                   } catch <span class="params">(ServletException e)</span> {
                       throw e;
                   } catch <span class="params">(Throwable e)</span> {
                       ExceptionUtils.handleThrowable<span class="params">(e)</span>;
                       throw new ServletException
                           <span class="params">(sm.getString<span class="params">(<span class="string">"standardWrapper.allocate"</span>)</span>, e)</span>;
                   }
               }
           }
       }

       <span class="keyword">if</span> <span class="params">(!instanceInitialized)</span> {
           initServlet<span class="params">(instance)</span>;
       }

       <span class="comment">//@2</span>
       <span class="keyword">if</span> <span class="params">(singleThreadModel)</span> {
           <span class="keyword">if</span> <span class="params">(newInstance)</span> {
               <span class="comment">// Have to do this outside of the sync above to prevent a</span>
               <span class="comment">// possible deadlock</span>
               synchronized <span class="params">(instancePool)</span> {
                   instancePool.push<span class="params">(instance)</span>;
                   nInstances++;
               }
           }
       } <span class="keyword">else</span> {
           <span class="keyword">if</span> <span class="params">(log.isTraceEnabled<span class="params">()</span>)</span>
               <span class="built_in">log</span>.trace<span class="params">(<span class="string">"  Returning non-STM instance"</span>)</span>;
           <span class="comment">// For new instances, count will have been incremented at the</span>
           <span class="comment">// time of creation</span>
           <span class="keyword">if</span> <span class="params">(!newInstance)</span> {
               countAllocated.incrementAndGet<span class="params">()</span>;
           }
           return <span class="params">(instance)</span>;
       }
   }
</code></pre><ul>
<li>@1用到了双检查锁，确保不会产生并发问题，并且在同步块里也是调用了之前看过的loadServlet方法</li>
<li>@2的是对singleThreadModel做处理，把对同一个servlet的不同实例放到了Stack集合里</li>
</ul>
<p>第二部分也是针对singleThreadModel做处理:</p>
<pre><code>synchronized <span class="params">(instancePool)</span> {

     while <span class="params">(countAllocated.get<span class="params">()</span> &gt;= nInstances)</span> {
         <span class="comment">// Allocate a new instance if possible, or else wait</span>
         <span class="keyword">if</span> <span class="params">(nInstances &lt; maxInstances)</span> {
             try {
                 instancePool.push<span class="params">(loadServlet<span class="params">()</span>)</span>;
                 nInstances++;
             } catch <span class="params">(ServletException e)</span> {
                 throw e;
             } catch <span class="params">(Throwable e)</span> {
                 ExceptionUtils.handleThrowable<span class="params">(e)</span>;
                 throw new ServletException
                     <span class="params">(sm.getString<span class="params">(<span class="string">"standardWrapper.allocate"</span>)</span>, e)</span>;
             }
         } <span class="keyword">else</span> {
             try {
                 instancePool.wait<span class="params">()</span>;
             } catch <span class="params">(InterruptedException e)</span> {
                 <span class="comment">// Ignore</span>
             }
         }
     }
     <span class="keyword">if</span> <span class="params">(log.isTraceEnabled<span class="params">()</span>)</span>
         <span class="built_in">log</span>.trace<span class="params">(<span class="string">"  Returning allocated STM instance"</span>)</span>;
     countAllocated.incrementAndGet<span class="params">()</span>;
     return instancePool.pop<span class="params">()</span>;

 }
</code></pre><ul>
<li>如果栈中的个数小于最大允许的阀值，就往stack中push实例化好的servlet,否则会对stack做一个阻塞操作,等有请求完毕后会调用notify方法唤醒stack变量</li>
</ul>
<h2 id="总结">总结</h2><ul>
<li>servlet的初始化会根据servlet配置的load-on-startup做出不同的初始化响应，如果值大于等于0，则会在容器启动时初始servlet,否则会在第一次调用的时候初始化</li>
<li>web.xml中的loadOnstartup是用来控制servlet的初始化顺序，同时控制了servlet是否在容器启动的时候初始化？</li>
<li>servlet初始化并发主要是通过synchronized同步块+双检查锁的机制。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.getsetter.cn/2014/08/01/servlet_init/" data-id="cid7fvg450007yfxeqhq76d16" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



    
      <article id="post-tomcat_http_parse" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexo-theme-icarus/2014/07/22/tomcat_http_parse/">tomcat之http解析和keepalive(bio篇)</a>
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/hexo-theme-icarus/2014/07/22/tomcat_http_parse/">
      <time datetime="2014-07-22T15:18:42.000Z" itemprop="datePublished">2014-07-22</time>
    </a>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <p>##前言<br>基本上所有的工程师都需要和web、浏览器打交道，对编写servlet也是非常地熟练，而中间的容器层往往是大家比较缺乏的知识，如果你对tomcat如何解析http请求，keepalive等功能感兴趣请往下看。</p>
<p><a href="http://www.getsetter.cn/2014/07/19/tomcat_comet/">tomcat comet的处理</a>中已经介绍过tomcat的组件由连接器和容器2部分组成，这一章节的内容主要涉及到连接器的一些内容，并且本文讨论的是基于BIO的处理，nio和apr的以后再开篇讨论。</p>
<p>##开始</p>
<p>###连接器的简单处理流程</p>
<p>下面是一个忽略了Container内部实现的请求流程图</p>
<p><img src="http://www.getsetter.cn/img/tomcat_connector.jpg" alt="tomcat_connector.jpg"></p>
<ol>
<li><p>tomcat会用serverSocket监听tcp端口，然后会把socket包装成一个socketWrapper对象扔到线程池中处理。</p>
<pre><code>SocketWrapper&lt;Socket&gt; wrapper = new SocketWrapper&lt;Socket&gt;<span class="params">(socket)</span>;
wrapper.setKeepAliveLeft<span class="params">(getMaxKeepAliveRequests<span class="params">()</span>)</span>;
<span class="comment">// During shutdown, executor may be null - avoid NPE</span>
<span class="keyword">if</span> <span class="params">(!running)</span> {
    return <span class="literal">false</span>;
}
getExecutor<span class="params">()</span>.execute<span class="params">(new SocketProcessor<span class="params">(wrapper)</span>)</span>;
</code></pre><p>我们关注一下socketWrapper对象中的一些属性：</p>
<pre><code><span class="keyword">protected</span> <span class="keyword">volatile</span> E socket;

<span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastAccess = -<span class="number">1</span>;
<span class="keyword">protected</span> <span class="keyword">long</span> timeout = -<span class="number">1</span>;
<span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="keyword">error</span> = <span class="keyword">false</span>;
<span class="keyword">protected</span> <span class="keyword">long</span> lastRegistered = <span class="number">0</span>;
<span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">int</span> keepAliveLeft = <span class="number">100</span>;
<span class="keyword">protected</span> <span class="keyword">boolean</span> async = <span class="keyword">false</span>;
<span class="keyword">protected</span> <span class="keyword">boolean</span> keptAlive = <span class="keyword">false</span>;

<span class="function"><span class="keyword">public</span> <span class="title">SocketWrapper</span><span class="params">(E socket)</span> </span>{
    <span class="keyword">this</span>.socket = socket;
}
</code></pre><ol>
<li>lastAccess: 对于长连接使用，意思是一个socket最近一次请求的时间，内容是System.currentTimeMills()</li>
<li>timeout:</li>
<li>keepAliveLeft:长连接中支持的最大请求数，如果值为小于等于1，则会断开socket连接，这个值可以在Connector标签中配置，属性值是maxKeepAliveRequests，默认值时100。</li>
<li>async: 是否是基于servlet3.0的异步请求,默认是false</li>
<li>keptAlive: 是否是长连接，默认为false</li>
</ol>
</li>
<li><p>其中绿色的Handler和Processor会根据不同的协议(http、ajp)和不同的流读写方式（bio、nio、apr）有不同的实现方式，这里我们关注http+bio的实现。</p>
</li>
<li>Processor是本文讨论的重点(具体是AbstractHttp11Processor),这个类负责解析http流，后面servelt的很多信息如requestURI、queryString等信息也是在这里做转换的，当然这里也对keep-alive长连接做了一些处理。</li>
</ol>
<p>###tomcat如何解析http流</p>
<p>对于不熟悉http协议的同学，请看下<a href="http://tools.ietf.org/html/rfc2616" target="_blank" rel="external">RFC2616</a>,这个我最近也在看,还有很多没搞明白就不在这里献丑解释了。但是对于http请求格式一定要弄清楚：</p>
<pre><code><span class="request">GET <span class="string">/aa/bb</span> HTTP/1.1</span>
<span class="attribute">Host</span>: <span class="string">localhost:8899</span>
<span class="attribute">Connection</span>: <span class="string">keep-alive</span>
<span class="attribute">Cache-Control</span>: <span class="string">max-age=0</span>
<span class="attribute">Accept</span>: <span class="string">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span>
<span class="attribute">User-Agent</span>: <span class="string">Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36</span>
<span class="attribute">Accept-Encoding</span>: <span class="string">gzip,deflate,sdch</span>
<span class="attribute">Accept-Language</span>: <span class="string">zh-CN,zh;q=0.8,en;q=0.6</span>
<span class="attribute">Cookie</span>: <span class="string">__atuvc=11%7C23%2C0%7C24%2C0%7C25%2C2%7C26</span>
</code></pre><ol>
<li>所有http的第一行叫做请求行，由三部分组成：请求方式(GET) 请求url(/aa/bb)、http版本(HTTP/1.1),并且以\r\n结束</li>
<li>接着第二行开始的都是一些kv信息，并且每一行也是以\r\n结束</li>
<li>最后会以一个空行加上\r\n标识头部的结束</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.getsetter.cn/2014/07/22/tomcat_http_parse/" data-id="cid7fvg3r0002yfxetwn3473r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



    
      <article id="post-tomcat_comet" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexo-theme-icarus/2014/07/18/tomcat_comet/">tomcat comet的处理过程</a>
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/hexo-theme-icarus/2014/07/18/tomcat_comet/">
      <time datetime="2014-07-18T14:59:03.000Z" itemprop="datePublished">2014-07-18</time>
    </a>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <p>#前言#<br>comet是一种服务端反推消息给客户端的一种技术，比如聊天室、电子邮件的场景。在comet出现之前有很多方案，更早之前想实现数据的不断更新，就要不断的通过js来不断地重新装载页面来获取新数据，后来AJAX的出现，可以实现局部刷新的功能,但是AJAX的方式也有局限性，因为他必须通过轮询来调后台接口，这样轮询的周期怎么来把控，如果设置地太长，获取的信息可能有滞后；如果设置地太短，客户端和服务端都会消耗很多不必要TCP连接开销。<br><br>而本文讨论的comet技术的实现原理：不关闭response的连接，当有数据更新不断地通过这个连接往客户端push数据。而客户端用ajax的方式检查readyState 的值是否为3，然后获取response回来的数据。</p>
<p>##tomcat的实现<br>tomcat自带了一个CometProcessor接口，这个接口继承了Servlet接口。所以如果你想实现comet，就让你的servlet实现CometProcessor接口。CometProcessor只有一个方法</p>
<pre><code><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">event</span><span class="params">(CometEvent event)</span>
        <span class="keyword">throws</span> IOException, ServletException</span>;
</code></pre><p>###先了解下comet相关的类</p>
<p>上面知道所有的servelt都要实现cometProcessor类，这个类只有一个event方法，参数是CometEvent，看一下下图的类结构</p>
<p> <img src="http://www.getsetter.cn/img/comet_class.jpg" alt="comet_class.jpg"></p>
<ol>
<li>CometEvent内部维护了一个枚举类型的事件状态eventType，这里有4种事件类型:<ul>
<li>BEGIN: 当连接开始时</li>
<li>READ: 每次新数据可用时</li>
<li>END： 连接结束</li>
<li>ERROR：流程抛异常或者出错，这个状态还有几个子事件类型subEventType,有的时候为了更准确地记录下出错的原因，分离出子状态是有必要的。</li>
</ul>
</li>
<li>用户需要根据这4种不同的类型做不同的业务逻辑处理，所有event可能会有大量的if else语句。</li>
</ol>
<p>###回顾tomcat处理的流程<br>从tomcat的功能划分可以把tomcat分为连接器和容器2部分，这里不做过多分析，只说一个大概的流程：从客户端一个http请求开始，客户端会把消息发送到Connector监听的socket端口上，tomcat自己实现了一个http协议栈用来解析http消息(这里也可以单独写一篇文章)，解析出来的数据会封装成tomcat内部的request和response对象,从解析出来的request数据中提取engine、host、context、wrapper等信息，最终通过pipline模式找到对应的servlet(在tomcat内部一个wrapper对象就是对应了一个servlet运行信息)，调用service()方法完成一次请求。</p>
<p>先暂时忽略Connector的处理部分，这里重点关注下从拿到tomcat解析完数据并生成tomcat内部的request后开始。<br>tomcat拿到请求数据后，会交给tomcat的容器部分，tomcat的容器会由4个组件构成，Engine、Host、Context和Wrapper,组件的具体含义请参考我之前写过的一篇<a href="http://www.getsetter.cn/2014/06/25/tomcat-component/">tomcat组件</a>。这4个组件其实并不是平行的，而是父子关系，这几个对象最终都会继承自Container对象，每一个Container对象都会有一个pipline，pipline我们太熟悉了，那valve在哪里定义，每一个容器默认都会在构造函数里都会自带一个valve,比如wrapper构造函数的定义是下面代码所示：</p>
<pre><code> public <span class="type">StandardWrapper</span><span class="literal">()</span> {        
         super<span class="literal">()</span>;
         swValve=<span class="keyword">new</span> <span class="type">StandardWrapperValve</span><span class="literal">()</span>;
         pipeline.setBasic(swValve);
         broadcaster = <span class="keyword">new</span> <span class="type">NotificationBroadcasterSupport</span><span class="literal">()</span>;        
}
</code></pre><p>而如果想自己定义valve，也可以在server.xml中定义。</p>
<p>因此我们基本肯定tomcat容器部分的处理是通过pipline方式运行的，如果不是很确定，就可以到CoyoteAdapter.service(request,response)方法(这个方法是tomcat容器部分的开始)中查看,在tomcat7的408行我们会看到这么一句话</p>
<pre><code><span class="tag">connector</span><span class="class">.getService</span>()<span class="class">.getContainer</span>()<span class="class">.getPipeline</span>()<span class="class">.getFirst</span>()<span class="class">.invoke</span>(<span class="tag">request</span>, <span class="tag">response</span>);
</code></pre><ol>
<li>connector.getService().getContainer()这里拿到的是最顶层的容器，即Engine对象</li>
<li>getPipeline().getFirst() 拿到engine对象的pipline的第一个阀门</li>
<li>invoke(request, response) 所有的valve都必须实现invoke方法，这里就开始执行了第一个管道的第一个阀门方法</li>
</ol>
<p>这样，pipline就开始工作了，由于上面提到过容器的几个组件都是父子关系，因此每个容器组件都可以拿到他的子容器组件，因此每当一个pipline中的valve都执行完，就会执行子pipline的valve动作。</p>
<p>下面这幅图是我从imTiger网站扣的一张图，这张图已经足以说明tomcat pipline的处理流程。</p>
<p><img src="http://www.getsetter.cn/img/tomcat_process.jpg" alt="tomcat_process.jpg"></p>
<p>###comet的开始</p>
<p>上文说到Wrapper组件其实代表了一个servlet。servlet的处理过程也是从这里开始，我们看一下StandardWrapperValve的这个类,这个类的功能是根据请求匹配对应的servlet,如果第一次请求就会反射创建一个实例并调用init方法，再看下面的代码：</p>
<pre><code><span class="comment">// Identify if the request is Comet related now that the servlet has been allocated</span>
<span class="keyword">boolean</span> comet = <span class="keyword">false</span>;
<span class="keyword">if</span> (servlet <span class="keyword">instanceof</span> CometProcessor &amp;&amp;  == <span class="keyword">Boolean</span>.<span class="keyword">TRUE</span>) {
    comet = <span class="keyword">true</span>;
    request.setComet(<span class="keyword">true</span>);
}
</code></pre><ol>
<li>开头的时候说过只有servlet实现了CometProcessor接口，tomcat才能实现comet功能。因此他这里判断了servlet是不是实现了CometProcessor接口，</li>
<li><p>request.getAttribute(Globals.COMET_SUPPORTED_ATTR)，这个属性是在容器启动构造组件的时候设置的，默认情况下nio和apr的模式是true。因此comet必须要nio或者apr的支持，这个只需要把Connector标签的内容换成如下的配置即可</p>
<pre><code><span class="tag">&lt;<span class="title">Connector</span> <span class="attribute">connectionTimeout</span>=<span class="value">"20000"</span> <span class="attribute">port</span>=<span class="value">"8080"</span> 
   <span class="attribute">protocol</span>=<span class="value">"org.apache.coyote.http11.Http11NioProtocol"</span> <span class="attribute">redirectPort</span>=<span class="value">"8443"</span>/&gt;</span>
</code></pre></li>
</ol>
<p>接着往下看：</p>
<pre><code>try {
    <span class="keyword">if</span> <span class="params">(<span class="params">(servlet != null)</span> &amp;&amp; <span class="params">(filterChain != null)</span>)</span> {
        <span class="comment">// Swallow output if needed</span>
        <span class="keyword">if</span> <span class="params">(context.getSwallowOutput<span class="params">()</span>)</span> {
            try {
                SystemLogHandler.startCapture<span class="params">()</span>;
                <span class="keyword">if</span> <span class="params">(request.isAsyncDispatching<span class="params">()</span>)</span> {
                    <span class="comment">//TODO SERVLET3 - async</span>
                    <span class="params">(<span class="params">(AsyncContextImpl)</span>request.getAsyncContext<span class="params">()</span>)</span>.doInternalDispatch<span class="params">()</span>; 
                } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(comet)</span> {
                    filterChain.doFilterEvent<span class="params">(request.getEvent<span class="params">()</span>)</span>;
                    request.setComet<span class="params">(<span class="literal">true</span>)</span>;
                } <span class="keyword">else</span> {
                    filterChain.doFilter<span class="params">(request.getRequest<span class="params">()</span>, 
                            response.getResponse<span class="params">()</span>)</span>;
                }
            } finally {
                String <span class="built_in">log</span> = SystemLogHandler.stopCapture<span class="params">()</span>;
                <span class="keyword">if</span> <span class="params">(log != null &amp;&amp; log.length<span class="params">()</span> &gt; <span class="number">0</span>)</span> {
                    context.getLogger<span class="params">()</span>.info<span class="params">(log)</span>;
                }
            }
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> <span class="params">(request.isAsyncDispatching<span class="params">()</span>)</span> {
                <span class="comment">//TODO SERVLET3 - async</span>
                <span class="params">(<span class="params">(AsyncContextImpl)</span>request.getAsyncContext<span class="params">()</span>)</span>.doInternalDispatch<span class="params">()</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(comet)</span> {
                request.setComet<span class="params">(<span class="literal">true</span>)</span>;
                filterChain.doFilterEvent<span class="params">(request.getEvent<span class="params">()</span>)</span>;
            } <span class="keyword">else</span> {
                filterChain.doFilter
                    <span class="params">(request.getRequest<span class="params">()</span>, response.getResponse<span class="params">()</span>)</span>;
            }
        }

    }
</code></pre><ol>
<li>非comet，这里会调用doFilter方法，方法会依次执行web.xml中的filter，最后执行servlet。</li>
<li><p>comet的情况会调用doFilterEvent方法。该方法会先执行所有实现了filterComet接口的类(当然上面没提这个接口，这是为filter提供的comet实现)，这个方法最终会调用ApplicationFilterChain的internalDoFilterEvent()方法，看这个方法的关键代码：</p>
<pre><code><span class="keyword">if</span><span class="params">( Globals.IS_SECURITY_ENABLED )</span> {
        final CometEvent ev = event;
        Principal principal = 
            ev.getHttpServletRequest<span class="params">()</span>.getUserPrincipal<span class="params">()</span>;
        Object[] args = new Object[]{ ev };
        SecurityUtil.doAsPrivilege<span class="params">(<span class="string">"event"</span>,
                servlet,
                classTypeUsedInEvent, 
                args,
                principal)</span>;
    } <span class="keyword">else</span> {  
        <span class="params">(<span class="params">(CometProcessor)</span> servlet)</span>.event<span class="params">(event)</span>;
    }
</code></pre><ol>
<li>这里最终会调用到cometProcessor的event方法，如果是第一次请求,参数CometEvent的事件类型会是BEGIN的状态。</li>
</ol>
</li>
</ol>
<p>###流程还没有完</p>
<p>上面的方法是完成了一个连接的建立，并已经成功调用到了我们自己编写的event方法里，但是上面的只是一个连接创建的事件，那数据的读取事件什么时候发生。莫急，一般第一次请求过来都会带有一个消息过来，只是tomcat按照事件的先后顺序先执行了连接创建的事件。接着到CoyoteAdapter.service()方法里看后面的流程：</p>
<pre><code><span class="keyword">if</span> <span class="params">(event<span class="params">(req, res, SocketStatus.OPEN)</span>)</span> {
    comet = <span class="literal">true</span>;
    res.action<span class="params">(ActionCode.COMET_BEGIN, null)</span>;
}
</code></pre><ol>
<li>这里会调到event方法，并传入了一个Socket打开的状态。</li>
<li><p>看一下event方法</p>
<pre><code><span class="keyword">if</span> <span class="params">(status == SocketStatus.OPEN)</span> {
      <span class="keyword">if</span> <span class="params">(response.isClosed<span class="params">()</span>)</span> {
          <span class="comment">// The event has been closed asynchronously, so call end instead of</span>
          <span class="comment">// read to cleanup the pipeline</span>
          request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.END)</span>;
          request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(null)</span>;
      } <span class="keyword">else</span> {
          try {
              <span class="comment">// Fill the read buffer of the servlet layer\</span>
              <span class="comment">// @1</span>
              <span class="keyword">if</span> <span class="params">(request.read<span class="params">()</span>)</span> {
                  read = <span class="literal">true</span>;
              }
          } catch <span class="params">(IOException e)</span> {
              error = <span class="literal">true</span>;
          }
          <span class="keyword">if</span> <span class="params">(read)</span> {
              request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.READ)</span>;
              request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(null)</span>;
          } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(error)</span> {
              request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.ERROR)</span>;
              request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(CometEvent.EventSubType.CLIENT_DISCONNECT)</span>;
          } <span class="keyword">else</span> {
              request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.END)</span>;
              request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(null)</span>;
          }
      }
  } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(status == SocketStatus.DISCONNECT)</span> {
      request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.ERROR)</span>;
      request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(CometEvent.EventSubType.CLIENT_DISCONNECT)</span>;
      error = <span class="literal">true</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(status == SocketStatus.ERROR)</span> {
      request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.ERROR)</span>;
      request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(CometEvent.EventSubType.IOEXCEPTION)</span>;
      error = <span class="literal">true</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(status == SocketStatus.STOP)</span> {
      request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.END)</span>;
      request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(CometEvent.EventSubType.SERVER_SHUTDOWN)</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(status == SocketStatus.TIMEOUT)</span> {
      <span class="keyword">if</span> <span class="params">(response.isClosed<span class="params">()</span>)</span> {
          <span class="comment">// The event has been closed asynchronously, so call end instead of</span>
          <span class="comment">// read to cleanup the pipeline</span>
          request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.END)</span>;
          request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(null)</span>;
      } <span class="keyword">else</span> {
          request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.ERROR)</span>;
          request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(CometEvent.EventSubType.TIMEOUT)</span>;
      }
  }

  req.getRequestProcessor<span class="params">()</span>.setWorkerThreadName<span class="params">(Thread.currentThread<span class="params">()</span>.getName<span class="params">()</span>)</span>;

  <span class="comment">// Calling the container</span>
  <span class="comment">// @2</span>
  connector.getService<span class="params">()</span>.getContainer<span class="params">()</span>.getPipeline<span class="params">()</span>.getFirst<span class="params">()</span>.event<span class="params">(request, response, request.getEvent<span class="params">()</span>)</span>;

  <span class="keyword">if</span> <span class="params">(!error &amp;&amp; !response.isClosed<span class="params">()</span> &amp;&amp; <span class="params">(request.getAttribute<span class="params">(
          RequestDispatcher.ERROR_EXCEPTION)</span> != null)</span>)</span> {
      <span class="comment">// An unexpected exception occurred while processing the event, so</span>
      <span class="comment">// error should be called</span>
      request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.ERROR)</span>;
      request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(null)</span>;
      error = <span class="literal">true</span>;
      connector.getService<span class="params">()</span>.getContainer<span class="params">()</span>.getPipeline<span class="params">()</span>.getFirst<span class="params">()</span>.event<span class="params">(request, response, request.getEvent<span class="params">()</span>)</span>;
  }
  <span class="keyword">if</span> <span class="params">(response.isClosed<span class="params">()</span> || !request.isComet<span class="params">()</span>)</span> {
      <span class="keyword">if</span> <span class="params">(status==SocketStatus.OPEN &amp;&amp;
              request.getEvent<span class="params">()</span>.getEventType<span class="params">()</span> != EventType.END)</span> {
          <span class="comment">//CometEvent.close was called during an event other than END</span>
          request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.END)</span>;
          request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(null)</span>;
          error = <span class="literal">true</span>;
          connector.getService<span class="params">()</span>.getContainer<span class="params">()</span>.getPipeline<span class="params">()</span>.getFirst<span class="params">()</span>.event<span class="params">(request, response, request.getEvent<span class="params">()</span>)</span>;
      }
      res.action<span class="params">(ActionCode.COMET_END, null)</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(!error &amp;&amp; read &amp;&amp; request.getAvailable<span class="params">()</span>)</span> {
      <span class="comment">// If this was a read and not all bytes have been read, or if no data</span>
      <span class="comment">// was read from the connector, then it is an error</span>
      request.getEvent<span class="params">()</span>.setEventType<span class="params">(CometEvent.EventType.ERROR)</span>;
      request.getEvent<span class="params">()</span>.setEventSubType<span class="params">(CometEvent.EventSubType.IOEXCEPTION)</span>;
      error = <span class="literal">true</span>;
      connector.getService<span class="params">()</span>.getContainer<span class="params">()</span>.getPipeline<span class="params">()</span>.getFirst<span class="params">()</span>.event<span class="params">(request, response, request.getEvent<span class="params">()</span>)</span>;
  }
  return <span class="params">(!error)</span>;
</code></pre><ol>
<li>标注@1的代码会去读请求的内容 看一下是否有数据。如果有，就把事件设置为READ事件，其他的几个条件大家可以自己试着理解。</li>
<li>标注@2的代码看到了和之前adapt中调用pipline中类似的语句，之前是调用的invoke，现在是event()方法。先不看里面的逻辑，这个方法是干嘛用的？既然已经有READ()事件了，那怎么把这个事件发送给servlet呢。这里的event()就是干的这个事。里面的实现和上个章节介绍的差不多。</li>
</ol>
</li>
</ol>
<p>所有valve的基类ValveBase有2个最基本的抽象方法：</p>
<ul>
<li>invoke(Request request, Response response)：处理非comet的请求和第一次comet的BEGIN的事件</li>
<li>event(Request request,Response response,CometEvent event)：处理所有comet请求的事件。</li>
</ul>
<p>###tomcat提供的例子<br>        @Override<br>        public void event(CometEvent event) throws IOException,<br>                ServletException {</p>
<pre><code>        HttpServletRequest request = event.getHttpServletRequest<span class="params">()</span>;
        HttpServletResponse response = event.getHttpServletResponse<span class="params">()</span>;

        HttpSession session = request.getSession<span class="params">(<span class="literal">true</span>)</span>;
        session.setMaxInactiveInterval<span class="params">(<span class="number">30</span>)</span>;

        lastEvent = event.getEventType<span class="params">()</span>;

        <span class="keyword">if</span> <span class="params">(event.getEventType<span class="params">()</span> == EventType.BEGIN)</span> {
            <span class="keyword">if</span> <span class="params">(failOnBegin)</span> {
                throw new IOException<span class="params">(<span class="string">"Fail on begin"</span>)</span>;
            }
            response.setContentType<span class="params">(<span class="string">"text/plain"</span>)</span>;
            response.getWriter<span class="params">()</span>.print<span class="params">(<span class="string">"BEGIN"</span> + <span class="string">"\r\n"</span>)</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(event.getEventType<span class="params">()</span> == EventType.READ)</span> {
            <span class="keyword">if</span> <span class="params">(failOnRead)</span> {
                throw new IOException<span class="params">(<span class="string">"Fail on read"</span>)</span>;
            }
            InputStream is = request.getInputStream<span class="params">()</span>;
            int count = <span class="number">0</span>;
            while <span class="params">(is.available<span class="params">()</span> &gt; <span class="number">0</span>)</span> {
                is.read<span class="params">()</span>;
                count ++;
            }
            String msg = <span class="string">"READ: "</span> + count + <span class="string">" bytes"</span>;
            response.getWriter<span class="params">()</span>.print<span class="params">(<span class="string">"Client: "</span> + msg + <span class="string">"\r\n"</span>)</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(event.getEventType<span class="params">()</span> == EventType.END)</span> {
            endEventOccurred = <span class="literal">true</span>;
            <span class="keyword">if</span> <span class="params">(failOnEnd)</span> {
                throw new IOException<span class="params">(<span class="string">"Fail on end"</span>)</span>;
            }
            String msg = <span class="string">"END"</span>;
            response.getWriter<span class="params">()</span>.print<span class="params">(<span class="string">"Client: "</span> + msg + <span class="string">"\r\n"</span>)</span>;
            event.close<span class="params">()</span>;
        } <span class="keyword">else</span> {
            response.getWriter<span class="params">()</span>.print<span class="params">(event.getEventSubType<span class="params">()</span> + <span class="string">"\r\n"</span>)</span>;
            event.close<span class="params">()</span>;
        }
        response.getWriter<span class="params">()</span>.flush<span class="params">()</span>;
    }
}
</code></pre><p>###总结</p>
<p>上面介绍的方式只适合基于tomcat容器的应用，其他容器的comet实现请参考其他文档。如果你不希望编写一个基于某个容器的实现的解决方案，那有个利好的消息是servlet3.0将会推出一个规范来支持基于事件的NIO，然后由不同的容器自己去实现，这个就好比servlet标准一样，有了标准我们就不需要关注具体的实现，关于servlet3.0的处理请参考<a href="http://www.ibm.com/developerworks/cn/java/j-lo-comet/" target="_blank" rel="external">这里</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.getsetter.cn/2014/07/18/tomcat_comet/" data-id="cid7fvg3w0003yfxeq37h7ozs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



    
      <article id="post-netty5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexo-theme-icarus/2014/07/15/netty5/">netty5 用户指南</a>
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/hexo-theme-icarus/2014/07/15/netty5/">
      <time datetime="2014-07-15T11:17:03.000Z" itemprop="datePublished">2014-07-15</time>
    </a>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <h2 id="前言">前言</h2><h3 id="问题">问题</h3><p>现如今我们使用通用的应用程序或者类库来实现系统之间地互相访问，比如我们经常使用一个HTTP客户端来从web服务器上获取信息，或者通过web service来执行一个远程的调用。</p>
<p>然而，一个通用的协议和他的实现有时候并没有覆盖一些场景。比如我们无法使用一个通用的http服务器来对庞大的文件和电子邮件进行交互，再比如也无法处理那种准实时消息比如财务信息和多人游戏数据。我们需要一个高效的协议实现用来处理一些特殊的场景。例如你可以实现一个高效的基于Ajax的聊天应用、媒体流传输或者是大文件传输的http服务器，你甚至可能想自己设计和实现一整个新的协议来准确地定制你自己的需求。</p>
<p>另外不可避免的事情是你不得不处理这些私有协议来确保和原有系统的互通。在这个例子中会告诉你实现一个对应该程序不损耗稳定性和性能的协议是多么的快。</p>
<h2 id="解决方案">解决方案</h2><p><a href="http://netty.io/" target="_blank" rel="external">Netty</a>是一个提供异步事件驱动的网络应用框架，可以为服务端和客户端提供一个快速迭代开发的高性能、高伸缩性的协议。</p>
<p>换句话说，Netty是一个能够快速简单地来开发网络应用程序的NIO框架比如客户端和服务端的协议，Netty大大简化了网络程序的开发过程比如TCP和UDP的 Socket的开发。</p>
<p>快速和简单并不等于一个应用会产生可维护性和性能的问题，Netty是一个被精心设计的框架，他从许多协议的实现中吸收了很多的经验比如FTP,SMTP,HTTP和许多二进制和基于文本的传统协议，Netty已经成功地找出了解决方案并且在不妥协开发效率、性能、稳定性、灵活性情况下。</p>
<p>有一些用户可能已经发现其他的一些网络框架声称自己也有同样的优势，所以你可能会问是Netty和他们有什么不一样。答案就是NETTY的哲学设计理念。Netty从第一天开始就把API和实现设计成为你提供最舒适的使用体验。NETTY的设计理念会使当你阅读本指南并且和Netty打交道的时候，让你的使用变得更加简单。<br>，可以为服务端和客户端提供一个快速迭代开发的高性能、高伸缩性的协议。</p>
<p>换句话说，Netty是一个能够快速简单地来开发网络应用程序的NIO框架比如客户端和服务端的协议，Netty大大简化了网络程序的开发过程比如TCP和UDP的 Socket的开发。</p>
<p>快速和简单并不等于一个应用会产生可维护性和性能的问题，Netty是一个被精心设计的框架，他从许多协议的实现中吸收了很多的经验比如FTP,SMTP,HTTP和许多二进制和基于文本的传统协议，Netty已经成功地找出了解决方案并且在不妥协开发效率、性能、稳定性、灵活性情况下。</p>
<p>有一些用户可能已经发现其他的一些网络框架声称自己也有同样的优势，所以你可能会问是Netty和他们有什么不一样。答案就是NETTY的哲学设计理念。Netty从第一天开始就把API和实现设计成为你提供最舒适的使用体验。NETTY的设计理念会使当你阅读本指南并且和Netty打交道的时候，让你的使用变得更加简单。<br>是一个提供异步事件驱动的网络应用框架，可以为服务端和客户端提供一个快速迭代开发的高性能、高伸缩性的协议。</p>
<p>换句话说，Netty是一个能够快速简单地来开发网络应用程序的NIO框架比如客户端和服务端的协议，Netty大大简化了网络程序的开发过程比如TCP和UDP的 Socket的开发。</p>
<p>快速和简单并不等于一个应用会产生可维护性和性能的问题，Netty是一个被精心设计的框架，他从许多协议的实现中吸收了很多的经验比如FTP,SMTP,HTTP和许多二进制和基于文本的传统协议，Netty已经成功地找出了解决方案并且在不妥协开发效率、性能、稳定性、灵活性情况下。</p>
<p>有一些用户可能已经发现其他的一些网络框架声称自己也有同样的优势，所以你可能会问是Netty和他们有什么不一样。答案就是NETTY的哲学设计理念。Netty从第一天开始就把API和实现设计成为你提供最舒适的使用体验。NETTY的设计理念会使当你阅读本指南并且和Netty打交道的时候，让你的使用变得更加简单。</p>
<h2 id="入门指南">入门指南</h2><p>这个章节会围绕NETTY核心的结构并附上一些简单的例子让你快速的入门。当你读完本章节你马上就可以用Netty写出一个客户端和一个服务端。</p>
<p>如果你在学习某些东西的时候喜欢自顶向下的方法，你可能想要从第二个章节架构概述开始，然后再回到这里。</p>
<h3 id="开始之前">开始之前</h3><p>如果要运行本章节中的2个例子最低要求是：NETTY的最新版本(Netty5)和JDK1.6及以上。最新的NETTY版本在项目<a href="http://netty.io/downloads.html" target="_blank" rel="external">下载页面</a>。为了下载到正确的JDK版本，请到你偏爱的网站下载。</p>
<p>当你在读的过程中，你可能有很多关于本章节介绍的类相关的问题，每当你想知道他们的更多的信息那么请参考API说明文档。为了方便，所有文档中涉及到的类名字都会被关联到一个在线的API说明。当然如果有任何错误信息、语法错误或者你有任何好的建议来改进文档说明，那么请联系<a href="http://netty.io/community.html" target="_blank" rel="external">netty社区</a>。</p>
<h3 id="DISCARD服务(丢弃服务，指的是会忽略所有接收的数据的一种协议)">DISCARD服务(丢弃服务，指的是会忽略所有接收的数据的一种协议)</h3><p>世界上最简单的协议不是”Hello,World!”，是<a href="http://tools.ietf.org/html/rfc863" target="_blank" rel="external">DISCARD</a>，他是一种丢弃了所有接受到的数据，并不做有任何的响应的协议。</p>
<p>为了实现DISCARD协议，你唯一需要做的就是忽略所有收到的数据。让我们从处理器的实现开始，处理器是由Netty生成用来处理I/O事件的。</p>
<pre><code><span class="keyword">package</span> io.netty.example.discard;

<span class="keyword">import</span> io.netty.buffer.<span class="type">ByteBuf</span>;

<span class="keyword">import</span> io.netty.channel.<span class="type">ChannelHandlerContext</span>;
<span class="keyword">import</span> io.netty.channel.<span class="type">ChannelHandlerAdapter</span>;

<span class="comment">/**
 * Handles a server-side channel.
 */</span>
public <span class="class"><span class="keyword">class</span> <span class="title">DiscardServerHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ChannelHandlerAdapter</span> {</span> <span class="comment">// (1)</span>

    <span class="annotation">@Override</span>
    public void channelRead(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg) { <span class="comment">// (2)</span>
        <span class="comment">// Discard the received data silently.</span>
        ((<span class="type">ByteBuf</span>) msg).release(); <span class="comment">// (3)</span>
    }

    <span class="annotation">@Override</span>
    public void exceptionCaught(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Throwable</span> cause) { <span class="comment">// (4)</span>
        <span class="comment">// Close the connection when an exception is raised.</span>
        cause.printStackTrace();
        ctx.close();
    }
}
</code></pre><ol>
<li>DisCardServerHandler 继承自 <a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" target="_blank" rel="external">ChannelHandlerAdapter</a>，这个类实现了<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>接口，<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>提供了许多事件处理的接口方法，然后你可以覆盖这些方法。现在仅仅只需要继承<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerAdapter.html" target="_blank" rel="external">ChannelHandlerAdapter</a>类而不是你自己去实现接口方法。</li>
<li>这里我们覆盖了chanelRead()事件处理方法。每当从客户端收到新的数据时，这个方法会在收到消息时被调用，这个例子中，收到的消息的类型是<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a></li>
<li><p>为了实现DISCARD协议，处理器不得不忽略所有接受到的消息。<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>是一个引用计数对象，这个对象必须显示地调用release()方法来释放。请记住处理器的职责是释放所有传递到处理器的引用计数对象。通常，channelRead()方法的实现就像下面的这段代码：</p>
<pre><code> <span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>{
    <span class="keyword">try</span> {
        <span class="comment">// Do something with msg</span>
    } <span class="keyword">finally</span> {
        ReferenceCountUtil.release(msg);
    }
}
</code></pre></li>
<li>exceptionCaught()事件处理方法是当出现Throwable对象才会被调用，即当Netty由于IO错误或者处理器在处理事件时抛出的异常时。在大部分情况下，捕获的异常应该被记录下来并且把关联的channel给关闭掉。然而这个方法的处理方式会在遇到不同异常的情况下有不同的实现，比如你可能想在关闭连接之前发送一个错误码的响应消息。</li>
</ol>
<p>到目前为止一切都还比较顺利，我们已经实现了DISCARD服务的一半功能，剩下的需要编写一个main()方法来启动服务端的DiscardServerHandler。</p>
<pre><code><span class="keyword">package</span> io.netty.example.discard;

<span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;

<span class="keyword">import</span> io.netty.channel.ChannelFuture;
<span class="keyword">import</span> io.netty.channel.ChannelInitializer;
<span class="keyword">import</span> io.netty.channel.ChannelOption;
<span class="keyword">import</span> io.netty.channel.EventLoopGroup;
<span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;
<span class="keyword">import</span> io.netty.channel.socket.SocketChannel;
<span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;

<span class="comment">/**
 * Discards any incoming data.
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardServer</span> </span>{

    <span class="keyword">private</span> <span class="keyword">int</span> port;

    <span class="function"><span class="keyword">public</span> <span class="title">DiscardServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>{
        <span class="keyword">this</span>.port = port;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{
        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">// (1)</span>
        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();
        <span class="keyword">try</span> {
            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap(); <span class="comment">// (2)</span>
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class) <span class="comment">// (3)</span>
             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() { <span class="comment">// (4)</span>
                 <span class="annotation">@Override</span>
                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{
                     ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());
                 }
             })
             .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)          <span class="comment">// (5)</span>
             .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (6)</span>

            <span class="comment">// Bind and start to accept incoming connections.</span>
            ChannelFuture f = b.bind(port).sync(); <span class="comment">// (7)</span>

            <span class="comment">// Wait until the server socket is closed.</span>
            <span class="comment">// In this example, this does not happen, but you can do that to gracefully</span>
            <span class="comment">// shut down your server.</span>
            f.channel().closeFuture().sync();
        } <span class="keyword">finally</span> {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        <span class="keyword">int</span> port;
        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) {
            port = Integer.parseInt(args[<span class="number">0</span>]);
        } <span class="keyword">else</span> {
            port = <span class="number">8080</span>;
        }
        <span class="keyword">new</span> DiscardServer(port).run();
    }
}
</code></pre><ol>
<li><a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="external">NioEventLoopGroup</a> 是用来处理I/O操作的多线程事件循环器，Netty提供了许多不同的<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>的实现用来处理不同传输协议。在这个例子中我们实现了一个服务端的应用，因此会有2个<a href="http://netty.io/5.0/api/io/netty/channel/nio/NioEventLoopGroup.html" target="_blank" rel="external">NioEventLoopGroup</a>会被使用。第一个经常被叫做‘boss’，用来接收进来的连接。第二个经常被叫做‘worker’，用来处理已经被接收的连接，一旦‘boss’接收到连接，就会把连接信息注册到‘worker’上。如何知道多少个线程已经被使用，如何映射到已经创建的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>s上都需要依赖于<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>的实现，并且可以通过构造函数来配置他们的关系。</li>
<li><a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="external">ServerBootstrap</a> 是一个启动NIO服务的辅助启动类。你可以在这个服务中直接使用<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>，但是这会是一个复杂的处理过程，在很多情况下你并不需要这样做。</li>
<li>这里我们指定使用<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>类来举例说明一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>如何接收进来的连接。</li>
<li>这里的事件处理类经常会被用来处理一个最近的已经接收的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>。<a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="external">ChannelInitializer</a>是一个特殊的处理类，他的目的是帮助使用者配置一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>。也许你想通过增加一些处理类比如DiscardServerHandle来配置一个新的<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>或者其对应的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>来实现你的网络程序。当你的程序变的复杂时，可能你会增加更多的处理类到pipline上，然后提取这些匿名类到最顶层的类上。</li>
<li>你可以设置这里指定的通道实现的配置参数。我们正在写一个TCP/IP的服务端，因此我们被允许设置socket的参数选项比如tcpNoDelay和keepAlive。请参考<a href="http://netty.io/5.0/api/io/netty/channel/ChannelOption.html" target="_blank" rel="external">ChannelOption</a>和详细的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelConfig.html" target="_blank" rel="external">ChannelConfig</a>实现的接口文档以此可以对ChannelOptions的有一个大概的认识。</li>
<li>你关注过option()和childOption()吗？option()是提供给<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>用来接收进来的连接。childOption()是提供给由父管道<a href="http://netty.io/5.0/api/io/netty/channel/ServerChannel.html" target="_blank" rel="external">ServerChannel</a>接收到的连接，在这个例子中也是<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>。</li>
<li>我们继续，剩下的就是绑定端口然后启动服务。这里我们在机器上绑定了机器所有网卡上的8080端口。当然现在你可以多次调用bind()方法(基于不同绑定地址)。</li>
</ol>
<p>恭喜！你已经完成熟练地完成了第一个基于NETTY的服务端程序。</p>
<p>###观察接收到的数据</p>
<p>现在我们已经编写出我们第一个服务端，我们需要测试一下他是否真的可以运行。最简单的测试方法是用telnet 命令。例如，你可以在命令行上输入telnet localhost 8080或者其他类型参数。</p>
<p>然而我们能说这个服务端是正常运行了吗？事实上我们也不知道因为他是一个discard服务，你根本不可能得到任何的响应。为了证明他仍然是在工作的，让我们修改服务端的程序来打印出他到底接收到了什么。</p>
<p>我们已经知道channelRead()方法是在数据被接收的时候调用。让我们放一些代码到DiscardServerHandler类的channelRead()方法。</p>
<pre><code>@<span class="function">Override
<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span>(<span class="params">ChannelHandlerContext ctx, Object msg</span>) </span>{
    ByteBuf <span class="keyword">in</span> = (ByteBuf) msg;
    <span class="keyword">try</span> {
        <span class="keyword">while</span> (<span class="keyword">in</span>.isReadable()) { <span class="comment">// (1)</span>
            System.<span class="keyword">out</span>.print((<span class="keyword">char</span>) <span class="keyword">in</span>.readByte());
            System.<span class="keyword">out</span>.flush();
        }
    } <span class="keyword">finally</span> {
        ReferenceCountUtil.release(msg); <span class="comment">// (2)</span>
    }
}
</code></pre><ol>
<li>这个低效的循环事实上可以简化为:System.out.println(in.toString(io.netty.util.CharsetUtil.US_ASCII))</li>
<li>或者，你可以在这里调用in.release()。</li>
</ol>
<p>如果你再次运行telnet命令，你将会看到服务端打印出了他所接收到的消息。<br>完整的discard server代码放在了<a href="http://netty.io/5.0/xref/io/netty/example/discard/package-summary.html" target="_blank" rel="external">io.netty.example.discard</a>包下面。</p>
<p>###ECHO服务（响应式协议）</p>
<p>到目前为止，我们虽然接收到了数据，但没有做任何的响应。然而一个服务端通常会对一个请求作出响应。让我们学习怎样在<a href="http://tools.ietf.org/html/rfc862" target="_blank" rel="external">ECHO</a>协议的实现下编写一个响应消息给客户端，这个协议针对任何接收的数据都会返回一个响应。</p>
<p>和discard server唯一不同的是把在此之前我们实现的channelRead()方法，返回所有的数据替代打印接收数据到控制台上的逻辑。因此，需要把channelRead()方法修改如下：</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>{
    ctx.write(msg); <span class="comment">// (1)</span>
    ctx.flush(); <span class="comment">// (2)</span>
}
</code></pre><ol>
<li><a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandlerContext.html," target="_blank" rel="external">ChannelHandlerContext</a>对象提供了许多操作，使你能够触发各种各样的I/O事件和操作。这里我们调用了write(Object)方法来逐字地把接受到的消息写入。请注意不同于DISCARD的例子我们并没有释放接受到的消息，这是因为当写入的时候NETTY已经帮我们释放了。</li>
<li>ctx.write(Object)方法不会使消息写入到通道上，他被缓冲在了内部，你需要调用ctx.flush()方法来把缓冲区中数据强行输出。或者你可以用更简洁的cxt.writeAndFlush(msg)以达到同样的目的。</li>
</ol>
<p>如果你再一次运行telnet命令，你会看到服务端会发回一个你已经发送的消息。<br>完整的echo服务的代码放在了<a href="http://netty.io/5.0/xref/io/netty/example/echo/package-summary.html" target="_blank" rel="external">io.netty.example.echo</a>包下面。</p>
<p>###TIME服务(时间协议的服务)</p>
<p>在这个部分被实现的协议是<a href="http://tools.ietf.org/html/rfc868" target="_blank" rel="external">TIME</a>协议。和之前的例子不同的是在不接受任何请求时他会发送一个含32位的整数的消息，并且一旦消息发送就会立即关闭连接。在这个例子中，你会学习到如何构建和发送一个消息，然后在完成时主动关闭连接。</p>
<p>因为我们将会忽略任何接收到的数据，而只是在连接被创建发送一个消息，所以这次我们不能使用channelRead()方法了，代替他的是，我们需要覆盖channelActive()方法，下面的就是实现的内容：</p>
<pre><code><span class="keyword">package</span> io.netty.example.time;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>{

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx)</span> </span>{ <span class="comment">// (1)</span>
        <span class="keyword">final</span> ByteBuf time = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (2)</span>
        time.writeInt((<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000L</span> + <span class="number">2208988800L</span>));

        <span class="keyword">final</span> ChannelFuture f = ctx.writeAndFlush(time); <span class="comment">// (3)</span>
        f.addListener(<span class="keyword">new</span> ChannelFutureListener() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>{
                <span class="keyword">assert</span> f == future;
                ctx.close();
            }
        }); <span class="comment">// (4)</span>
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>{
        cause.printStackTrace();
        ctx.close();
    }
}
</code></pre><ol>
<li>channelActive()方法将会在连接被建立并且准备进行通信时被调用。因此让我们在这个方法里完成一个代表当前时间的32位整数消息的构建工作。</li>
<li>为了发送一个新的消息，我们需要分配一个包含这个消息的新的缓冲。因为我们需要写入一个32位的整数，因此我们需要一个至少有4个字节的<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>。通过ChannelHandlerContext.alloc()得到一个当前的ByteBufAllocator，然后分配一个新的缓冲。</li>
<li><p>和往常一样我们需要编写一个构建好的消息。但是等一等，flip在哪？难道我们使用NIO发送消息时不是调用java.nio.ByteBuffer.flip()吗？ByteBuf之所以没有这个方法因为有两个指针，一个对应读操作一个对应写操作。当你向ByteBuf里写入数据的时候写指针的索引就会增加，同时读指针的索引没有变化。读指针索引和写指针索引分别代表了消息的开始和结束。<br><br>比较起来，NIO缓冲并没有提供一种简洁的方式来计算出消息内容的开始和结尾，除非你调用flip方法。当你忘记调用flip方法而引起没有数据或者错误数据被发送时，你会陷入困境。这样的一个错误不会发生在Netty上，因为我们对于不同的操作类型有不同的指针。你会发现这样的使用方法会让你过程变得更加的容易，因为你已经习惯一种没有使用flip的方式。<br><br>另外一个点需要注意的是ChannelHandlerContext.write()(和writeAndFlush())方法会返回一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a>对象，一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a>代表了一个还没有发生的I/O操作。这意味着任何一个请求操作都不会马上被执行，因为在Netty里所有的操作都是异步的。举个例子下面的代码中在消息被发送之前可能会先关闭连接。</p>
<pre><code>Channel ch = ...<span class="comment">;</span>
ch.writeAndFlush(message)<span class="comment">;</span>
ch.close()<span class="comment">;</span>
</code></pre><p>因此你需要在write()方法返回的ChannelFuture完成后调用close()方法，然后当他的写操作已经完成他会通知他的监听者。请注意,close()方法也可能不会立马关闭，他也会返回一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFuture.html" target="_blank" rel="external">ChannelFuture</a>。</p>
</li>
<li><p>当一个写请求已经完成是如何通知到我们？这个只需要简单地在返回的ChannelFuture上增加一个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="external">ChannelFutureListener</a>。这里我们构建了一个匿名的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelFutureListener.html" target="_blank" rel="external">ChannelFutureListener</a>类用来在操作完成时关闭Channel。<br><br>或者，你可以使用简单的预定义监听器代码:</p>
<pre><code><span class="tag">f</span><span class="class">.addListener</span>(<span class="tag">ChannelFutureListener</span><span class="class">.CLOSE</span>);
</code></pre></li>
</ol>
<p>为了测试我们的time服务如我们期望的一样工作，你可以使用UNIX的rdate命令</p>
<pre><code>$ rdate -o <span class="tag">&lt;<span class="title">port</span>&gt;</span> -p <span class="tag">&lt;<span class="title">host</span>&gt;</span>
</code></pre><p>Port是你在main()函数中指定的端口，host使用locahost就可以了。</p>
<p>###Time客户端</p>
<p>不像DISCARD和ECHO的服务端，对于TIME协议我们需要一个客户端因为人们不能把一个32位的二进制数据翻译成一个日期或者日历。在这一部分，我们将会讨论如何确保服务端是正常工作的，并且学习怎样用NETTY编写一个客户端。</p>
<p>在Netty中,编写服务端和客户端最大的并且唯一不同的使用了不同的<a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="external">BootStrap</a>和<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">Channel</a>的实现。请看一下下面的代码：</p>
<pre><code><span class="keyword">package</span> io.netty.example.time;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClient</span> </span>{
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        String host = args[<span class="number">0</span>];
        <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);
        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();

        <span class="keyword">try</span> {
            Bootstrap b = <span class="keyword">new</span> Bootstrap(); <span class="comment">// (1)</span>
            b.group(workerGroup); <span class="comment">// (2)</span>
            b.channel(NioSocketChannel.class); <span class="comment">// (3)</span>
            b.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); <span class="comment">// (4)</span>
            b.<span class="keyword">handler</span>(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {
                <span class="annotation">@Override</span>
                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{
                    ch.pipeline().addLast(<span class="keyword">new</span> TimeClientHandler());
                }
            });

            <span class="comment">// Start the client.</span>
            ChannelFuture f = b.connect(host, port).sync(); <span class="comment">// (5)</span>

            <span class="comment">// Wait until the connection is closed.</span>
            f.channel().closeFuture().sync();
        } <span class="keyword">finally</span> {
            workerGroup.shutdownGracefully();
        }
    }
}
</code></pre><ol>
<li><a href="http://netty.io/5.0/api/io/netty/bootstrap/Bootstrap.html" target="_blank" rel="external">BootStrap</a>和<a href="http://netty.io/5.0/api/io/netty/bootstrap/ServerBootstrap.html" target="_blank" rel="external">ServerBootstrap</a>类似,不过他是对非服务端的channel而言，比如客户端或者无连接传输模式的channel。</li>
<li>如果你只指定了一个<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>，那他就会即作为一个‘boss’线程，也会作为一个‘workder’线程，尽管客户端不需要使用到‘boss’线程。</li>
<li>代替<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioServerSocketChannel.html" target="_blank" rel="external">NioServerSocketChannel</a>的是<a href="http://netty.io/5.0/api/io/netty/channel/socket/nio/NioSocketChannel.html" target="_blank" rel="external">NioSocketChannel</a>,这个类在客户端channel被创建时使用。</li>
<li>不像在使用ServerBootstrap时需要用childOption()方法，因为客户端的<a href="http://netty.io/5.0/api/io/netty/channel/socket/SocketChannel.html" target="_blank" rel="external">SocketChannel</a>没有父channel的概念。</li>
<li>我们用connect()方法代替了bind()方法。</li>
</ol>
<p>正如你看到的，他和服务端的代码是不一样的。<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>是如何实现的?他应该从服务端接受一个32位的整数消息，把他翻译成人们能读懂的格式，并打印翻译好的时间，最后关闭连接:</p>
<pre><code><span class="keyword">package</span> io.netty.example.time;

<span class="keyword">import</span> java.util.<span class="type">Date</span>;

public <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ChannelHandlerAdapter</span> {</span>
    <span class="annotation">@Override</span>
    public void channelRead(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg) {
        <span class="type">ByteBuf</span> m = (<span class="type">ByteBuf</span>) msg; <span class="comment">// (1)</span>
        <span class="keyword">try</span> {
            long currentTimeMillis = (m.readUnsignedInt() - <span class="number">2208988800</span>L) * <span class="number">1000</span>L;
            <span class="type">System</span>.out.println(<span class="keyword">new</span> <span class="type">Date</span>(currentTimeMillis));
            ctx.close();
        } <span class="keyword">finally</span> {
            m.release();
        }
    }

    <span class="annotation">@Override</span>
    public void exceptionCaught(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Throwable</span> cause) {
        cause.printStackTrace();
        ctx.close();
    }
}
</code></pre><ol>
<li>在TCP/IP中，NETTY会把读到的数据放到ByteBuf的数据结构中。</li>
</ol>
<p>这样看起来非常简单，并且和服务端的那个例子的代码也相差不多。然而，处理器有时候会因为抛出IndexOutOfBoundsException而拒绝工作。在下个部分我们会讨论为什么会发生这种情况。</p>
<p>##流数据的传输处理</p>
<p>###一个小的Socket Buffer问题</p>
<p>在基于流的传输里比如TCP/IP，接收到的数据会先被存储到一个socket接收缓冲里。不幸的是，基于流的传输并不是一个数据包队列，而是一个字节队列。即使你发送了2个独立的数据包，操作系统也不会作为2个消息处理而仅仅是作为一连串的字节而言。因此这是不能保证你远程写入的数据就会准确地读取。举个例子，让我们假设操作系统的TCP/TP协议栈已经接收了3个数据包：</p>
<p><img src="http://www.getsetter.cn/img/netty5_1.png" alt="netty5_1.png"></p>
<p>由于基于流传输的协议的这种普通的性质，在你的应用程序里读取数据的时候会有很高的可能性被分成下面的片段。</p>
<p><img src="http://www.getsetter.cn/img/netty5_2.png" alt="netty5_2.png"></p>
<p>因此，一个接收方不管他是客户端还是服务端，都应该把接收到的数据整理成一个或者多个更有意思并且能够让程序的业务逻辑更好理解的数据。在上面的例子中，接收到的数据应该被构造成下面的格式：</p>
<p><img src="http://www.getsetter.cn/img/netty5_3.png" alt="netty5_3.png"></p>
<p>##第一个解决方案</p>
<p>现在让我们回到TIME客户端的例子上。这里我们遇到了同样的问题，一个32字节数据是非常小的数据量，他并不见得会被经常拆分到到不同的数据段内。然而，问题是他确实可能会被拆分到不同的数据段内，并且拆分的可能性会随着通信量的增加而增加。</p>
<p>最简单的方案是构造一个内部的可积累的缓冲，直到4个字节全部接收到了内部缓冲。下面的代码修改了TimeClientHandler的实现类修复了这个问题</p>
<pre><code><span class="keyword">package</span> io.netty.example.time;

<span class="keyword">import</span> java.util.Date;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>{
    <span class="keyword">private</span> ByteBuf buf;

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{
        buf = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (1)</span>
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{
        buf.release(); <span class="comment">// (1)</span>
        buf = <span class="keyword">null</span>;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>{
        ByteBuf m = (ByteBuf) msg;
        buf.writeBytes(m); <span class="comment">// (2)</span>
        m.release();

        <span class="keyword">if</span> (buf.readableBytes() &gt;= <span class="number">4</span>) { <span class="comment">// (3)</span>
            <span class="keyword">long</span> currentTimeMillis = (buf.readInt() - <span class="number">2208988800L</span>) * <span class="number">1000L</span>;
            System.out.println(<span class="keyword">new</span> Date(currentTimeMillis));
            ctx.close();
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>{
        cause.printStackTrace();
        ctx.close();
    }
}
</code></pre><ol>
<li><a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>有2个生命周期的监听方法：handlerAdded()和handlerRemoved()。你可以完成任意初始化任务只要他不会被阻塞很长的时间。</li>
<li>首先，所有接收的数据都应该被累积在buf变量里。</li>
<li>然后，处理器必须检查buf变量是否有足够的数据，在这个例子中是4个字节，然后处理实际的业务逻辑。否则，Netty会重复调用channelRead()当有更多数据到达直到4个字节的数据被积累。</li>
</ol>
<p>###第二个解决方案</p>
<p>尽管第一个解决方案已经解决了Time客户端的问题了，但是修改后的处理器看起来不那么的简洁，想象一下如果由多个字段比如可变长度的字段组成的更为复杂的协议时，你的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>的实现将很快地变得难以维护。</p>
<p>正如你所知的，你可以增加多个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a> ,因此你可以把一整个<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>拆分成多个模块以减少应用的复杂程度，比如你可以把TimeClientHandler拆分成2个处理器：</p>
<ul>
<li>TimeDecoder处理数据拆分的问题</li>
<li>TimeClientHandler原始版本的实现</li>
</ul>
<p>幸运地是，Netty提供了一个可扩展的类，帮你完成TimeDecoder的开发。</p>
<pre><code><span class="keyword">package</span> io.netty.example.time;

public <span class="class"><span class="keyword">class</span> <span class="title">TimeDecoder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ByteToMessageDecoder</span> {</span> <span class="comment">// (1)</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void decode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">ByteBuf</span> in, <span class="type">List</span>&lt;<span class="type">Object</span>&gt; out) { <span class="comment">// (2)</span>
        <span class="keyword">if</span> (in.readableBytes() &lt; <span class="number">4</span>) {
            <span class="keyword">return</span>; <span class="comment">// (3)</span>
        }

        out.add(in.readBytes(<span class="number">4</span>)); <span class="comment">// (4)</span>
    }
}
</code></pre><ol>
<li><a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>是<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>的一个实现类，他可以在处理数据拆分的问题上变得很简单。</li>
<li>每当有新数据接收的时候，<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>都会调用decode()方法来处理内部的那个累积缓冲。</li>
<li>Decode()方法可以决定当累积缓冲里没有足够数据时可以往out对象里放任意数据。当有更多的数据被接收了<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>会再一次调用decode()方法。</li>
<li>如果在decode()方法里增加了一个对象到out对象里，这意味着解码器解码消息成功。<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>将会丢弃在累积缓冲里已经被读过的数据。请记得你不需要对多条消息调用decode()，<a href="http://netty.io/5.0/api/io/netty/handler/codec/ByteToMessageDecoder.html" target="_blank" rel="external">ByteToMessageDecoder</a>会持续调用decode()直到不放任何数据到out里。</li>
</ol>
<p>现在我们有另外一个处理器插入到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>里，我们应该在TimeClient里修改<a href="http://netty.io/5.0/api/io/netty/channel/ChannelInitializer.html" target="_blank" rel="external">ChannelInitializer</a> 的实现：</p>
<pre><code>b.<span class="keyword">handler</span>(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {
    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{
        ch.pipeline().addLast(<span class="keyword">new</span> TimeDecoder(), <span class="keyword">new</span> TimeClientHandler());
    }
});
</code></pre><p>如果你是一个大胆的人，你可能会尝试使用更简单的解码类<a href="http://netty.io/5.0/api/io/netty/handler/codec/ReplayingDecoder.html" target="_blank" rel="external">ReplayingDecoder</a>。不过你还是需要参考一下API文档来获取更多的信息。</p>
<p>public class TimeDecoder extends ReplayingDecoder<void> {<br>    @Override<br>    protected void decode(<br>            ChannelHandlerContext ctx, ByteBuf in, List<object> out) {<br>        out.add(in.readBytes(4));<br>    }<br>}</object></void></p>
<p>此外，Netty还提供了更多可以直接拿来用的解码器使你可以更简单地实现更多的协议，帮助你避免开发一个难以维护的处理器实现。请参考下面的包以获取更多更详细的例子：</p>
<ul>
<li>对于二进制协议请看<a href="http://netty.io/5.0/xref/io/netty/example/factorial/package-summary.html" target="_blank" rel="external">io.netty.example.factorial</a></li>
<li>对于基于文本协议请看<a href="http://netty.io/5.0/xref/io/netty/example/telnet/package-summary.html" target="_blank" rel="external">io.netty.example.telnet</a></li>
</ul>
<p>##用POJO代替ByteBuf</p>
<p>我们已经讨论了所有的例子，到目前为止一个消息的消息都是使用<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>作为一个基本的数据结构。在这一部分，我们会改进TIME协议的客户端和服务端的例子，用POJO替代<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>。</p>
<p>在你的<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>S中使用POJO优势是比较明显的。通过从<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>中提取出ByteBuf的代码，将会使<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>的实现变得更加可维护和可重用。在TIME客户端和服务端的例子中，我们读取的仅仅是一个32位的整形数据，直接使用ByteBuf不会是一个主要的问题。然后，你会发现当你需要实现一个真实的协议，分离代码变得非常的必要。</p>
<p>首先，让我们定义一个新的类型叫做UnixTime。</p>
<pre><code>package io.netty.example.time;

import java.util.Date;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnixTime</span> {

    <span class="keyword">private</span> final <span class="keyword">int</span> <span class="keyword">value</span>;

    <span class="function"><span class="keyword">public</span> <span class="title">UnixTime</span>(<span class="params"></span>) </span>{
        <span class="keyword">this</span>((<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000</span>L + <span class="number">2208988800</span>L));
    }

    <span class="function"><span class="keyword">public</span> <span class="title">UnixTime</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>{
        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span>(<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="keyword">value</span>;
    }

    @<span class="function">Override
    <span class="keyword">public</span> String <span class="title">toString</span>(<span class="params"></span>) </span>{
        <span class="keyword">return</span> <span class="keyword">new</span> Date((<span class="keyword">value</span>() - <span class="number">2208988800</span>L) * <span class="number">1000</span>L).toString();
    }
}
</code></pre><p>现在我们可以修改下TimeDecoder类，返回一个UnixTime，以替代<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a></p>
<pre><code>@<span class="function">Override
<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span>(<span class="params">ChannelHandlerContext ctx, ByteBuf <span class="keyword">in</span>, List&lt;Object&gt; <span class="keyword">out</span></span>) </span>{
    <span class="keyword">if</span> (<span class="keyword">in</span>.readableBytes() &lt; <span class="number">4</span>) {
        <span class="keyword">return</span>;
    }

    <span class="keyword">out</span>.add(<span class="keyword">new</span> UnixTime(<span class="keyword">in</span>.readInt()));
}
</code></pre><p>下面是修改后的解码器，TimeClientHandler不再有任何的<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>代码了。</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>{
    UnixTime m = (UnixTime) msg;
    System.out.println(m);
    ctx.close();
}
</code></pre><p>是不是变得更加简单和优雅了？相同的技术可以被运用到服务端。让我们修改一下TimeServerHandler的代码。</p>
<pre><code><span class="annotation">@Override</span>
<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>{
    ChannelFuture f = ctx.writeAndFlush(<span class="keyword">new</span> UnixTime());
    f.addListener(ChannelFutureListener.CLOSE);
}
</code></pre><p>现在，仅仅需要修改的是<a href="http://netty.io/5.0/api/io/netty/channel/ChannelHandler.html" target="_blank" rel="external">ChannelHandler</a>的实现，这里需要把UnixTime对象重新转化为一个<a href="http://netty.io/5.0/api/io/netty/buffer/ByteBuf.html" target="_blank" rel="external">ByteBuf</a>。不过这已经是非常简单了，因为当你对一个消息编码的时候，你不需要再处理拆包和组装的过程。</p>
<pre><code><span class="keyword">package</span> io.netty.example.time;

public <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ChannelHandlerAdapter</span> {</span>
    <span class="annotation">@Override</span>
    public void write(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg, <span class="type">ChannelPromise</span> promise) {
        <span class="type">UnixTime</span> m = (<span class="type">UnixTime</span>) msg;
        <span class="type">ByteBuf</span> encoded = ctx.alloc().buffer(<span class="number">4</span>);
        encoded.writeInt(m.value());
        ctx.write(encoded, promise); <span class="comment">// (1)</span>
    }
}
</code></pre><ol>
<li>在这几行代码里还有几个重要的事情。<br><br>第一，    通过<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPromise.html" target="_blank" rel="external">ChannelPromise</a>，当编码后的数据被写到了通道上Netty可以通过这个对象标记是成功还是失败。<br><br>第二，    我们不需要调用cxt.flush()。因为处理器已经单独分离出了一个方法void flush(ChannelHandlerContext cxt),如果像自己实现flush方法内容可以自行覆盖这个方法。</li>
</ol>
<p>进一步简化操作，你可以使用<a href="http://netty.io/5.0/api/io/netty/handler/codec/MessageToByteEncoder.html" target="_blank" rel="external">MessageToByteEncode</a>:</p>
<pre><code>public <span class="class"><span class="keyword">class</span> <span class="title">TimeEncoder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">MessageToByteEncoder&lt;UnixTime&gt;</span> {</span>
    <span class="annotation">@Override</span>
    <span class="keyword">protected</span> void encode(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">UnixTime</span> msg, <span class="type">ByteBuf</span> out) {
        out.writeInt(msg.value());
    }
}
</code></pre><p>最后的任务就是在TimeServerHandler之前把TimeEncoder插入到<a href="http://netty.io/5.0/api/io/netty/channel/ChannelPipeline.html" target="_blank" rel="external">ChannelPipeline</a>。但这是不那么重要的工作。</p>
<p>##关闭你的应用</p>
<p>关闭一个Netty应用往往只需要简单地通过shutdownGracefully()方法来关闭你构建的所有的<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">NioEventLoopGroup</a>S.当<a href="http://netty.io/5.0/api/io/netty/channel/EventLoopGroup.html" target="_blank" rel="external">EventLoopGroup</a>被完全地终止,并且对应的所有<a href="http://netty.io/5.0/api/io/netty/channel/Channel.html" target="_blank" rel="external">channel</a>s都已经被关闭时，Netty会返回一个<a href="http://netty.io/5.0/api/io/netty/util/concurrent/Future.html" target="_blank" rel="external">Future</a>对象。</p>
<p>##概述</p>
<p>在这一章节中，我们会快速地回顾下如果在熟练掌握Netty的情况下编写出一个健壮能运行的网络应用程序。<br>在Netty接下去的章节中还会有更多更相信的信息。我们也鼓励你去重新复习下在<a href="https://github.com/netty/netty/tree/master/example/src/main/java/io/netty/example" target="_blank" rel="external">io.netty.example</a>包下的例子。<br>请注意<a href="http://netty.io/community.html" target="_blank" rel="external">社区</a>一直在等待你的问题和想法以帮助Netty的持续改进，Netty的文档也是基于你们的快速反馈上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.getsetter.cn/2014/07/15/netty5/" data-id="cid7fvg460008yfxe9ig55ve6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



    
      <article id="post-tomcat-component" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/hexo-theme-icarus/2014/06/25/tomcat-component/">tomcat组件</a>
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/hexo-theme-icarus/2014/06/25/tomcat-component/">
      <time datetime="2014-06-25T02:00:00.000Z" itemprop="datePublished">2014-06-25</time>
    </a>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <p>tomcat有一个核心配置文件叫做server.xml,这里声明了tomcat所有的运行组件，所以我们要了解tomcat组件就从这个配置文件开始，这个XML文件的解析工作则是交给了apache内部的一个xml生成java对象的工具叫<strong>Digester</strong>，apache软件基金会中的绝大多数项目也都是采用这个工具来解析xml的，比如struts。具体用法参考上一节的地址。</p>
<p>##组件<br><em>Catalina#createStartDegester()</em><br>上面的这个方法映射了每个标签和解析类的对应关系 并会把各个标签及其属性都会映射到对应解析类中的属性。下面简单介绍几个重要标签的含义：</p>
<p><img src="http://www.getsetter.cn/img/tomcat_componet.jpg" alt="jcc.jpg"></p>
<ul>
<li><p>server: 这个是server.xml的根元素，也是代表了整个servlet容器。他可以包含多个service组件。<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/server.html" target="_blank" rel="external">属性参考</a></p>
</li>
<li><p>service: 一个service是多个Connector组件+1个Engine（容器）组件构造而成，用来处理传入的请求。<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/service.html" target="_blank" rel="external">属性参考</a>，下面所列的组件都是service的一部分(都是在service标签内部)</p>
</li>
</ul>
<ul>
<li><p>Connector: 上面几个标签都不做实事的，只是一些包装，这个组件才是真正的工人，一个service可以包含一个或者多个Connector,这块逻辑也是整个TOMCAT代码里最有意思的部分。每一次请求servlet或者jsp，tomcat都会在一个特定的端口上进行TCP网络的监听，而Connector的http实现就是为了干这件事情，通过看代码其实背后就一个socket的通信机制。<br><br>很多时候我们为了能做负载均衡或者减少对tomcat的压力，会在tomcat前面放置一个web服务器(apache、ngix),那tomcat是怎么和web服务器通信呢，tomcat也实现了一个采用Ajp协议的Connector。同时为了防止过多的请求同时涌入容器处理队列，Connector内部也实现了一个连接池用来控制访问。具体下一章节会分析 <a href="http://tomcat.apache.org/tomcat-7.0-doc/config/http.html" target="_blank" rel="external">属性参考</a></p>
</li>
<li><p>Engine: Connector组件接受的消息会经过一层适配发送到Engine组件，接下来的servlet请求流程将会由Engine负责寻找匹配到工程的哪个servlet实例</p>
</li>
<li><p>Host:虚拟主机的配置，tomcat也支持多个不同的域名匹配到同一个ip，可以在Host标签下一级配置一个alias标签，属性和标签的具体配置参考<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/host.html#Host_Name_Aliases" target="_blank" rel="external">属性参考</a></p>
</li>
<li><p>Context:每一个web应用在tomcat内部都是以Context形式存在的，当我们在CATALINA_BASE/webapps下创建一个web应用时，默认都会创建一个名字为目录名的Context实例，当过来一个请求的URL的时候(比如<a href="http://127.0.0.1/getset),就会找到名字为为getset的Context实例。" target="_blank" rel="external">http://127.0.0.1/getset),就会找到名字为为getset的Context实例。</a><br>还有一种情况有些人不希望把工程的东西直接放在tomcat目录下，而是指定磁盘上的一个目录作为一个web应用，这时候也可以在host标签的子标签Context下配置，指定docBase（物理磁盘上的web应用路径）和path(请求的路径。)，但是这种方式tomcat官网是不建议配置，假如需要修改server.xml中的Context配置，在不重启tomcat的情况下是不可能重新加载的。<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/context.html" target="_blank" rel="external">属性参考</a></p>
</li>
<li><p>Executor:这个配置是一个线程池的实现，主要提供给Connector组件处理请求时的用的。在digester解析xml时，ConnectorCreateRule类会去把executor对象塞给Connector对象，代码如下，具体executor如何结合Connector组件见Connector这一章节。<br><a href="http://tomcat.apache.org/tomcat-7.0-doc/config/executor.html" target="_blank" rel="external">属性参考</a></p>
</li>
<li><p>Realm:访问容器的权限配置，默认会读conf/tomcat-users.xml文件，<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/realm.html" target="_blank" rel="external">属性参考</a></p>
<pre><code>  public void begin<span class="params">(String namespace, String name, Attributes attributes)</span>
        throws Exception {
    Service svc = <span class="params">(Service)</span>digester.peek<span class="params">()</span>;
    Executor ex = null;
    <span class="keyword">if</span> <span class="params">( attributes.getValue<span class="params">(<span class="string">"executor"</span>)</span>!=null )</span> {
        ex = svc.getExecutor<span class="params">(attributes.getValue<span class="params">(<span class="string">"executor"</span>)</span>)</span>;
    }
    Connector con = new Connector<span class="params">(attributes.getValue<span class="params">(<span class="string">"protocol"</span>)</span>)</span>;
    <span class="keyword">if</span> <span class="params">( ex != null )</span>  _setExecutor<span class="params">(con,ex)</span>;

    digester.push<span class="params">(con)</span>;
}

public void _setExecutor<span class="params">(Connector con, Executor ex)</span> throws Exception {
    Method m = IntrospectionUtils.findMethod<span class="params">(con.getProtocolHandler<span class="params">()</span>.getClass<span class="params">()</span>,<span class="string">"setExecutor"</span>,new Class[] {java.util.concurrent.Executor.class})</span>;
    <span class="keyword">if</span> <span class="params">(m!=null)</span> {
        m.invoke<span class="params">(con.getProtocolHandler<span class="params">()</span>, new Object[] {ex})</span>;
    }<span class="keyword">else</span> {
        <span class="built_in">log</span>.warn<span class="params">(<span class="string">"Connector ["</span>+con+<span class="string">"] does not support external executors. Method setExecutor(java.util.concurrent.Executor) not found."</span>)</span>;
    }
}
</code></pre></li>
</ul>
<p>##阅读前准备<br>想读tomcat源码，必须首先要了解其用法，读源码之前最好能够阅读下上面链接中的官方文档，里面的单词不多，基本都能读懂。<br><br>下面罗列一些读前提纲：</p>
<p>tomcat的启动的入口类是Bootstrap的main方法，这个方法的主要过程是：</p>
<ul>
<li>设置tomcat的相关的环境变量，包括主目录。</li>
<li>初始化classloader加载tomcat依赖的一些JAR。</li>
<li>用刚才生成的classloader去实例化tomcat真正的容器类Catalina，并把Catalina的parentClassLoader属性设置为当前的classloader。</li>
<li>根据不同的启动参数会调用Catalina类的不同方法，如果是启动tomcat,则会调用Catalina的start方法。</li>
</ul>
<p>catalina#start()方法干的事情主要是：</p>
<ul>
<li>用Digester解析server.xml并把映射的java对象到Catalina的server属性，因为我们知道server.xml的顶层标签就是server，所以server.xml的配置就可以通过catalina实例拿到server实例，再通过server实例拿到下面层级下的组件。</li>
<li>调用刚才生成的server实例(生成的实例的类型是StandardServer类)的start()方法启动tomcat。</li>
</ul>
<p>tomcat所有的组件都会有初始化、启动、停止和消亡的过程，因此tomcat抽象出了LifeCycle的接口(这个接口的javadoc上有一张神流程图，具体可以看这个类)。而由于很多组件在生命周期各个步骤都有公共的逻辑，因此tomcat又抽象出了一个抽象类LifecycleBase,这个类会去实现LifeCycle所有的方法的公共逻辑，并抽象出一个抽象方法供子类去实现，很经典的<strong>模板模式</strong>。每一个继承LifecycleBase的类都会有一个原子变量LifecycleState，这里记录了每一个组件的生命周期节点状态。这里重点分析下StandardServer的启动过程，StandardServer自己本身并没有直接实现Lifecycle接口，也是通过继承LifecycleBase类，所以当调用start()方法其实就是LifecycleBase的start方法。</p>
<ul>
<li><strong>1*</strong> LifecycleState#start()*:判断LifecycleState的状态是不是已经启动，如果是直接返回，如果是状态是新的，就会调用init()方法，这个方法主要还是调用提供给子类抽象方法initInternal()，完了后把状态标识为已经初始化。</li>
<li><strong>1.1</strong> <em>StandardServer#initInternal()</em>: 注册Mbean、遍历属性services数组，调用数组里每一个service的init方法。通过上面的图和分析，我们知道一个server可以包含多个service，而service里面的值时刚才通过Digester解析出来的(service的实例的类型是StandardService)，直接跳过init()方法，看一下StandardService的initInternal()。</li>
<li><p><strong>1.1.1</strong> <em>StandardService#initInternal()</em>:根据server.xml中的标签可以猜测一下service属性下至少会有1个Connector类型的数组和一个Engine类型的对象。看了类后发现Connector数组确实存在，而Engine对象确没有，去digester中看一下Engine的映射类，发现是StandardEngine,而这个类实现了Engine接口，Engine接口又实现了Container接口，所以StandardService中的container对象就是Engine的实例。看一下下面代码，非常清晰，engine(这里还是用engine保持和上下文一致)、executor和connector，这三个组件的大概意思在上面已经分析过了。</p>
<pre><code>    protected void initInternal<span class="params">()</span> throws LifecycleException {

    super.initInternal<span class="params">()</span>;

    <span class="keyword">if</span> <span class="params">(container != null)</span> {
        container.init<span class="params">()</span>;
    }

    <span class="comment">// Initialize any Executors</span>
    <span class="keyword">for</span> <span class="params">(Executor executor : findExecutors<span class="params">()</span>)</span> {
        <span class="keyword">if</span> <span class="params">(executor instanceof LifecycleMBeanBase)</span> {
            <span class="params">(<span class="params">(LifecycleMBeanBase)</span> executor)</span>.setDomain<span class="params">(getDomain<span class="params">()</span>)</span>;
        }
        executor.init<span class="params">()</span>;
    }

    <span class="comment">// Initialize our defined Connectors</span>
    synchronized <span class="params">(connectors)</span> {
        <span class="keyword">for</span> <span class="params">(Connector connector : connectors)</span> {
            try {
                connector.init<span class="params">()</span>;
            } catch <span class="params">(Exception e)</span> {
                String message = sm.getString<span class="params">(
                        <span class="string">"standardService.connector.initFailed"</span>, connector)</span>;
                <span class="built_in">log</span>.error<span class="params">(message, e)</span>;

                <span class="keyword">if</span> <span class="params">(Boolean.getBoolean<span class="params">(<span class="string">"org.apache.catalina.startup.EXIT_ON_INIT_FAILURE"</span>)</span>)</span>
                    throw new LifecycleException<span class="params">(message)</span>;
            }
        }
    }
}
</code></pre></li>
</ul>
<ul>
<li><strong>1.1.1.1</strong> <em>StandardEngine#init()</em>:创建了一个用linkedBlockingQueue的线程池startstopExecutor。</li>
<li><p><strong>1.1.1.2</strong> <em>Connector#init()</em>: 创建了一个Adapt对象，这个对象会把请求适配成标准的servlet请求模型request/response，调用servlet的service方法并通知所有的监听器。还会创建一个协议处理器protocolHandler,并调用init()方法，所以<strong>Connector组件主要是由Adapt和protocolHandler组成</strong>。</p>
<pre><code>protected void initInternal<span class="params">()</span> throws LifecycleException {

    super.initInternal<span class="params">()</span>;

    <span class="comment">// Initialize adapter</span>
    adapter = new CoyoteAdapter<span class="params">(this)</span>;
    protocolHandler.setAdapter<span class="params">(adapter)</span>;

    <span class="comment">// Make sure parseBodyMethodsSet has a default</span>
    <span class="keyword">if</span><span class="params">( null == parseBodyMethodsSet )</span> {
        setParseBodyMethods<span class="params">(getParseBodyMethods<span class="params">()</span>)</span>;
    }

    <span class="keyword">if</span> <span class="params">(protocolHandler.isAprRequired<span class="params">()</span> &amp;&amp;
            !AprLifecycleListener.isAprAvailable<span class="params">()</span>)</span> {
        throw new LifecycleException<span class="params">(
                sm.getString<span class="params">(<span class="string">"coyoteConnector.protocolHandlerNoApr"</span>,
                        getProtocolHandlerClassName<span class="params">()</span>)</span>)</span>;
    }

    try {
        protocolHandler.init<span class="params">()</span>;
    } catch <span class="params">(Exception e)</span> {
        throw new LifecycleException
            <span class="params">(sm.getString
             <span class="params">(<span class="string">"coyoteConnector.protocolHandlerInitializationFailed"</span>)</span>, e)</span>;
    }

    <span class="comment">// Initialize mapper listener</span>
    mapperListener.init<span class="params">()</span>;
</code></pre><p>   }</p>
</li>
<li><p><strong>1.1.1.2.1</strong> <em>AbstractProtocol#init()</em>: protocolHandler模块是由端点endpoint模块和connectionHandler组成，在这个方法中主要去初始化endpoint模块</p>
</li>
<li><p><strong>1.1.1.2.1.1</strong> <em>AbstractEndpoint#init()</em>:  bind()是一个抽象方法，实现由具体的子类的实现，实现的内容主要绑定不同协议的TCP端口，绑定的配置在server.xml中的Connector标签中配置，到这里所有的init步骤就全部完结了。</p>
<pre><code>  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;           
  <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{
   <span class="keyword">if</span> (bindOnInit) {
       bind();
       bindState = BindState.BOUND_ON_INIT;
   }
}                       
</code></pre></li>
<li><p><strong>1.2</strong> <em>StandardServer#startInternal()</em>: 所有组件初始化好后，会把server状态设置为STARTING_PREP。在server.xml中有很多的listener标签，这些listener是用来监听tomcat每个组件状态的变化，所以当server组件开始启动的时候，就会发出一个启动的消息给所有的监听者，当然如果你也有类似的需求，你可以可以自己实现LifecycleListener接口，并配置在server.xml中。接着会去调用每一个service的start方法。</p>
</li>
<li><strong>1.2.1</strong> <em>StandardService#startInternal()</em>: 和<strong>1.1.1</strong>中的<em>StandardService#initInternal()</em>方法类似，这个方法会分别去调用Engine、executor、connector的start()方法。</li>
<li><strong>1.2.1.1</strong> <em>StandardEngine#startInternal()</em>: Engine下其实也有很多的模块，比如Realm、Host、Cluster，Host里还有valve等，这里的东西不多大家看代码就能明白</li>
</ul>
<p><em>下一节：Connector</em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="www.getsetter.cn/2014/06/25/tomcat-component/" data-id="cid7fvg3x0004yfxeorcphjac" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



    
      <nav id="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/hexo-theme-icarus/page/2/">2</a><a class="extend next" rel="next" href="/hexo-theme-icarus/page/2/">Next &raquo;</a>
      </nav>
    </section>
      
        <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">recents</h3>
    <div class="widget">
      <ul id="recent-post" class="">
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/hexo-theme-icarus/2014/08/01/share_ali_tec_metting/" class="thumbnail">
  
    <span class="thumbnail-image thumbnail-none"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"></p>
              <p class="item-title"><a href="/hexo-theme-icarus/2014/08/01/share_ali_tec_metting/" class="title">参加阿里巴巴2015阿里系统技术峰会的感受</a></p>
              <p class="item-date"><time datetime="2014-08-01T15:25:17.000Z" itemprop="datePublished">2014-08-01</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/hexo-theme-icarus/2014/08/01/servlet_init/" class="thumbnail">
  
    <span class="thumbnail-image thumbnail-none"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"></p>
              <p class="item-title"><a href="/hexo-theme-icarus/2014/08/01/servlet_init/" class="title">tomcat初始化servlet代码剖析</a></p>
              <p class="item-date"><time datetime="2014-08-01T15:25:17.000Z" itemprop="datePublished">2014-08-01</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/hexo-theme-icarus/2014/07/22/tomcat_http_parse/" class="thumbnail">
  
    <span style="background-image:url(http://www.getsetter.cn/img/tomcat_connector.jpg
)" alt="tomcat之http解析和keepalive(bio篇)" class="thumbnail-image"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"></p>
              <p class="item-title"><a href="/hexo-theme-icarus/2014/07/22/tomcat_http_parse/" class="title">tomcat之http解析和keepalive(bio篇)</a></p>
              <p class="item-date"><time datetime="2014-07-22T15:18:42.000Z" itemprop="datePublished">2014-07-22</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/hexo-theme-icarus/2014/07/18/tomcat_comet/" class="thumbnail">
  
    <span style="background-image:url(http://www.getsetter.cn/img/comet_class.jpg
)" alt="tomcat comet的处理过程" class="thumbnail-image"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"></p>
              <p class="item-title"><a href="/hexo-theme-icarus/2014/07/18/tomcat_comet/" class="title">tomcat comet的处理过程</a></p>
              <p class="item-date"><time datetime="2014-07-18T14:59:03.000Z" itemprop="datePublished">2014-07-18</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/hexo-theme-icarus/2014/07/15/netty5/" class="thumbnail">
  
    <span style="background-image:url(http://www.getsetter.cn/img/netty5_1.png
)" alt="netty5 用户指南" class="thumbnail-image"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"></p>
              <p class="item-title"><a href="/hexo-theme-icarus/2014/07/15/netty5/" class="title">netty5 用户指南</a></p>
              <p class="item-date"><time datetime="2014-07-15T11:17:03.000Z" itemprop="datePublished">2014-07-15</time></p>
            </div>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/hexo-theme-icarus/archives/2014/08/">August 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexo-theme-icarus/archives/2014/07/">July 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexo-theme-icarus/archives/2014/06/">June 2014</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
  <div id="toTop" class="fa fa-chevron-up"></div>
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2000 - 2015 家栋<br>
    </div>
  </div>
</footer>
    

<script type="text/javascript">
  var duoshuoQuery = {short_name:"owenludong"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>


<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/hexo-theme-icarus/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/hexo-theme-icarus/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/hexo-theme-icarus/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>